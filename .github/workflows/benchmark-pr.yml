name: PR Benchmark

on:
  pull_request:
    types: [labeled]

env:
  AWS_REGION: us-east-1

jobs:
  # Deploy PR-specific C2 for pull request benchmarks
  deploy-pr-c2:
    name: Deploy PR C2
    runs-on: ubuntu-latest
    timeout-minutes: 15
    if: |
      github.event.label.name == 'bench-fast' ||
      github.event.label.name == 'bench-med' ||
      github.event.label.name == 'bench-metal'
    outputs:
      c2_url: ${{ steps.deploy.outputs.c2_url }}
      stack_name: ${{ steps.deploy.outputs.stack_name }}

    steps:
      - name: Checkout PR Code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha }}

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version-file: 'go.mod'

      - name: Build C2 Binary
        run: |
          echo "Building C2 binary from PR code..."
          GOOS=linux GOARCH=amd64 go build -o c2-linux-amd64 ./cmd/c2
          ls -la c2-linux-amd64

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Upload C2 Binary to S3
        id: upload
        run: |
          PR_NUMBER="${{ github.event.pull_request.number }}"
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          BUCKET="celeris-artifacts-${AWS_ACCOUNT_ID}"
          KEY="pr-c2/pr-${PR_NUMBER}/c2-linux-amd64"

          echo "Using bucket: $BUCKET"

          # Create bucket if it doesn't exist
          if ! aws s3api head-bucket --bucket "$BUCKET" 2>/dev/null; then
            echo "Creating bucket $BUCKET..."
            aws s3api create-bucket --bucket "$BUCKET" --region ${{ env.AWS_REGION }}
          fi

          # Upload binary
          aws s3 cp c2-linux-amd64 "s3://${BUCKET}/${KEY}"

          # Generate presigned URL (valid for 4 hours)
          URL=$(aws s3 presign "s3://${BUCKET}/${KEY}" --expires-in 14400)
          echo "binary_url=$URL" >> $GITHUB_OUTPUT
          echo "bucket=$BUCKET" >> $GITHUB_OUTPUT
          echo "Uploaded C2 binary to S3"

      - name: Get Main C2 Stack Outputs
        id: main-c2
        run: |
          # Get security group, instance profile, and role from main C2 stack
          WORKER_SG=$(aws cloudformation describe-stacks --stack-name celeris-c2 \
            --query 'Stacks[0].Outputs[?OutputKey==`WorkerSecurityGroupId`].OutputValue' --output text)
          WORKER_PROFILE=$(aws cloudformation describe-stacks --stack-name celeris-c2 \
            --query 'Stacks[0].Outputs[?OutputKey==`WorkerInstanceProfileArn`].OutputValue' --output text)
          WORKER_ROLE=$(aws cloudformation describe-stacks --stack-name celeris-c2 \
            --query 'Stacks[0].Outputs[?OutputKey==`WorkerRoleArn`].OutputValue' --output text)
          C2_SG=$(aws cloudformation describe-stacks --stack-name celeris-c2 \
            --query 'Stacks[0].Outputs[?OutputKey==`C2SecurityGroupId`].OutputValue' --output text)

          echo "worker_sg=$WORKER_SG" >> $GITHUB_OUTPUT
          echo "worker_profile=$WORKER_PROFILE" >> $GITHUB_OUTPUT
          echo "worker_role=$WORKER_ROLE" >> $GITHUB_OUTPUT
          echo "c2_sg=$C2_SG" >> $GITHUB_OUTPUT

      - name: Deploy PR C2 Stack
        id: deploy
        run: |
          PR_NUMBER="${{ github.event.pull_request.number }}"
          STACK_NAME="celeris-c2-pr-${PR_NUMBER}"

          echo "Deploying PR C2 stack: $STACK_NAME"

          aws cloudformation deploy \
            --template-file cloudformation/c2-pr.yaml \
            --stack-name "$STACK_NAME" \
            --capabilities CAPABILITY_NAMED_IAM \
            --parameter-overrides \
              PRNumber="$PR_NUMBER" \
              VpcId="${{ secrets.VPC_ID }}" \
              SubnetId="${{ secrets.SUBNET_ID }}" \
              ApiKey="${{ secrets.C2_API_KEY }}" \
              GitHubToken="${{ secrets.GH_PAT_RUNNER_TOKEN }}" \
              C2BinaryUrl="${{ steps.upload.outputs.binary_url }}" \
              MainC2SecurityGroupId="${{ steps.main-c2.outputs.c2_sg }}" \
              WorkerSecurityGroupId="${{ steps.main-c2.outputs.worker_sg }}" \
              WorkerInstanceProfileArn="${{ steps.main-c2.outputs.worker_profile }}" \
              WorkerRoleArn="${{ steps.main-c2.outputs.worker_role }}" \
            --tags \
              Project=celeris-benchmarks \
              PRNumber="$PR_NUMBER" \
            --no-fail-on-empty-changeset

          # Get outputs
          C2_IP=$(aws cloudformation describe-stacks --stack-name "$STACK_NAME" \
            --query 'Stacks[0].Outputs[?OutputKey==`PRC2PublicIP`].OutputValue' --output text)
          C2_URL="http://${C2_IP}:8080"

          echo "stack_name=$STACK_NAME" >> $GITHUB_OUTPUT
          echo "c2_url=$C2_URL" >> $GITHUB_OUTPUT
          echo "PR C2 deployed at: $C2_URL"

      - name: Wait for PR C2 to be Healthy
        run: |
          C2_URL="${{ steps.deploy.outputs.c2_url }}"
          echo "Waiting for PR C2 to be healthy at $C2_URL..."

          for i in {1..60}; do
            if curl -sf "$C2_URL/api/health" > /dev/null 2>&1; then
              echo "PR C2 is healthy!"
              exit 0
            fi
            echo "Attempt $i/60: PR C2 not ready yet..."
            sleep 10
          done

          echo "::error::PR C2 health check failed"
          exit 1

  # Main benchmark job
  benchmark:
    name: Run Benchmark
    runs-on: ubuntu-latest
    timeout-minutes: 240
    needs: [deploy-pr-c2]
    permissions:
      contents: write
      pull-requests: write

    steps:
      - name: Determine Benchmark Mode
        id: mode
        run: |
          # Determine mode from label
          LABEL="${{ github.event.label.name }}"
          case "$LABEL" in
            bench-fast) MODE="fast" ;;
            bench-med)  MODE="med" ;;
            bench-metal) MODE="metal" ;;
            *) MODE="fast" ;;
          esac
          echo "mode=$MODE" >> $GITHUB_OUTPUT
          echo "Running $MODE benchmarks for PR (label: $LABEL)"

      - name: Start Benchmark
        id: start
        run: |
          C2_URL="${{ needs.deploy-pr-c2.outputs.c2_url }}"
          echo "Starting benchmark (mode: ${{ steps.mode.outputs.mode }}) against $C2_URL"

          PARAMS="mode=${{ steps.mode.outputs.mode }}"

          RESPONSE=$(curl -sf -X POST \
            -H "X-API-Key: ${{ secrets.C2_API_KEY }}" \
            "$C2_URL/api/benchmark/start?$PARAMS")

          RUN_ID=$(echo "$RESPONSE" | jq -r '.run_id')
          if [[ -z "$RUN_ID" || "$RUN_ID" == "null" ]]; then
            echo "::error::Failed to start benchmark: $RESPONSE"
            exit 1
          fi

          echo "run_id=$RUN_ID" >> $GITHUB_OUTPUT
          echo "Benchmark started: $RUN_ID"

      - name: Wait for Completion
        run: |
          C2_URL="${{ needs.deploy-pr-c2.outputs.c2_url }}"
          RUN_ID="${{ steps.start.outputs.run_id }}"
          echo "Waiting for benchmark $RUN_ID to complete..."

          POLL_INTERVAL=30
          MAX_WAIT=14400  # 4 hours
          ELAPSED=0
          LAST_QUEUE_POS=0
          PLACEMENT_SHOWN=false

          while [ $ELAPSED -lt $MAX_WAIT ]; do
            RESPONSE=$(curl -sf \
              -H "X-API-Key: ${{ secrets.C2_API_KEY }}" \
              "$C2_URL/api/benchmark/$RUN_ID/status" || echo '{"status":"unknown"}')

            STATUS=$(echo "$RESPONSE" | jq -r '.status')

            case $STATUS in
              completed)
                echo "Benchmark completed successfully!"
                exit 0
                ;;
              failed|cancelled)
                ERROR=$(echo "$RESPONSE" | jq -r '.error // "Unknown error"')
                echo "::error::Benchmark failed: $ERROR"
                exit 1
                ;;
              queued)
                # Show queue position
                QUEUE_POS=$(echo "$RESPONSE" | jq -r '.queue_position // 0')
                if [[ "$QUEUE_POS" != "$LAST_QUEUE_POS" ]]; then
                  echo "[$((ELAPSED/60))m] Queued - position $QUEUE_POS (waiting for capacity)"
                  LAST_QUEUE_POS=$QUEUE_POS
                fi
                ;;
              pending|running)
                # Show worker placement info once when ALL 4 workers register
                if [[ "$PLACEMENT_SHOWN" == "false" ]]; then
                  WORKERS=$(echo "$RESPONSE" | jq -c '.workers // {}')
                  if [[ "$WORKERS" != "{}" ]]; then
                    # Check if all 4 workers are registered
                    HAS_ALL_WORKERS=true
                    for arch in arm64 x86; do
                      for role in server client; do
                        KEY="${arch}-${role}"
                        WORKER=$(echo "$RESPONSE" | jq -r ".workers[\"$KEY\"] // empty")
                        if [[ -z "$WORKER" ]]; then
                          HAS_ALL_WORKERS=false
                        fi
                      done
                    done

                    if [[ "$HAS_ALL_WORKERS" == "true" ]]; then
                      echo ""
                      echo "=== Worker Placement ==="
                      for arch in arm64 x86; do
                        for role in server client; do
                          KEY="${arch}-${role}"
                          WORKER=$(echo "$RESPONSE" | jq -r ".workers[\"$KEY\"]")
                          W_TYPE=$(echo "$WORKER" | jq -r '.instance_type // "unknown"')
                          W_REGION=$(echo "$WORKER" | jq -r '.region // "unknown"')
                          W_AZ=$(echo "$WORKER" | jq -r '.az // "unknown"')
                          echo "  $arch $role: $W_TYPE in $W_REGION ($W_AZ)"
                        done
                      done
                      echo "========================="
                      echo ""
                      PLACEMENT_SHOWN=true
                    fi
                  fi
                fi

                # Show progress
                echo "[$((ELAPSED/60))m] Status: $STATUS"
                WORKERS=$(echo "$RESPONSE" | jq -c '.workers // {}')
                if [[ "$WORKERS" != "{}" ]]; then
                  # Extract and display progress from workers
                  for arch in arm64 x86; do
                    CLIENT_KEY="${arch}-client"
                    CLIENT=$(echo "$RESPONSE" | jq -r ".workers[\"$CLIENT_KEY\"] // {}")
                    if [[ "$CLIENT" != "{}" && "$CLIENT" != "null" ]]; then
                      CURRENT_SERVER=$(echo "$CLIENT" | jq -r '.current_server // ""')
                      CURRENT_BENCH=$(echo "$CLIENT" | jq -r '.current_benchmark // ""')
                      CURRENT_COUNT=$(echo "$CLIENT" | jq -r '.current_count // 0')
                      TOTAL_COUNT=$(echo "$CLIENT" | jq -r '.total_count // 0')

                      if [[ -n "$CURRENT_SERVER" && -n "$CURRENT_BENCH" && "$TOTAL_COUNT" -gt 0 ]]; then
                        echo "  $arch: Testing $CURRENT_SERVER/$CURRENT_BENCH ($CURRENT_COUNT/$TOTAL_COUNT)"
                      fi
                    fi
                  done
                fi
                ;;
              *)
                echo "[$((ELAPSED/60))m] Unknown status: $STATUS"
                ;;
            esac

            sleep $POLL_INTERVAL
            ELAPSED=$((ELAPSED + POLL_INTERVAL))
          done

          echo "::error::Timeout waiting for benchmark completion"
          exit 1

      - name: Get Full Results
        id: results
        if: success()
        run: |
          C2_URL="${{ needs.deploy-pr-c2.outputs.c2_url }}"
          RUN_ID="${{ steps.start.outputs.run_id }}"
          if [[ -z "$RUN_ID" ]]; then
            echo "No run ID available"
            exit 0
          fi

          # Fetch full results
          RESULTS=$(curl -sf \
            -H "X-API-Key: ${{ secrets.C2_API_KEY }}" \
            "$C2_URL/api/benchmark/$RUN_ID/results" || echo '{}')

          # Store results for later steps
          echo "$RESULTS" > results.json
          echo "results_file=results.json" >> $GITHUB_OUTPUT

          # Get status
          STATUS_RESPONSE=$(curl -sf \
            -H "X-API-Key: ${{ secrets.C2_API_KEY }}" \
            "$C2_URL/api/benchmark/$RUN_ID/status" || echo '{}')

          echo "$STATUS_RESPONSE" > status.json
          echo "status=$(echo "$STATUS_RESPONSE" | jq -r '.status // "unknown"')" >> $GITHUB_OUTPUT

      - name: Generate Results Summary
        if: success()
        run: |
          C2_URL="${{ needs.deploy-pr-c2.outputs.c2_url }}"
          RUN_ID="${{ steps.start.outputs.run_id }}"
          MODE="${{ steps.mode.outputs.mode }}"

          # Generate markdown summary
          echo "## Benchmark Results - ${MODE^^} Mode" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Run ID:** \`$RUN_ID\`" >> $GITHUB_STEP_SUMMARY
          echo "**Status:** ${{ steps.results.outputs.status }}" >> $GITHUB_STEP_SUMMARY
          echo "**C2:** PR-specific (PR #${{ github.event.pull_request.number }})" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Show worker placement info
          echo "### Worker Placement" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Architecture | Role | Instance Type | Region | AZ |" >> $GITHUB_STEP_SUMMARY
          echo "|--------------|------|---------------|--------|-----|" >> $GITHUB_STEP_SUMMARY

          # Fetch status to get worker info
          STATUS_RESPONSE=$(curl -sf \
            -H "X-API-Key: ${{ secrets.C2_API_KEY }}" \
            "$C2_URL/api/benchmark/$RUN_ID/status" || echo '{}')

          for arch in arm64 x86; do
            for role in server client; do
              KEY="${arch}-${role}"
              WORKER=$(echo "$STATUS_RESPONSE" | jq -r ".workers[\"$KEY\"] // {}")
              if [[ "$WORKER" != "{}" && "$WORKER" != "null" ]]; then
                W_TYPE=$(echo "$WORKER" | jq -r '.instance_type // "-"')
                W_REGION=$(echo "$WORKER" | jq -r '.region // "-"')
                W_AZ=$(echo "$WORKER" | jq -r '.az // "-"')
                echo "| $arch | $role | \`$W_TYPE\` | $W_REGION | $W_AZ |" >> $GITHUB_STEP_SUMMARY
              fi
            done
          done
          echo "" >> $GITHUB_STEP_SUMMARY

          for arch in arm64 x86; do
            ARCH_RESULTS=$(jq -r ".$arch // {}" results.json)
            ARCH_STATUS=$(echo "$ARCH_RESULTS" | jq -r '.status // "pending"')
            BENCHMARKS=$(echo "$ARCH_RESULTS" | jq -r '.benchmarks // []')
            COUNT=$(echo "$BENCHMARKS" | jq 'length')

            if [[ "$COUNT" -gt 0 ]]; then
              echo "### $arch Results" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "| Server | Req/sec | Avg Latency | P99 Latency | Errors |" >> $GITHUB_STEP_SUMMARY
              echo "|--------|---------|-------------|-------------|--------|" >> $GITHUB_STEP_SUMMARY

              echo "$BENCHMARKS" | jq -r '.[] | "| \(.server_type) | \(.requests_per_sec | floor) | \(.latency_avg / 1000000 | . * 100 | floor / 100)ms | \(.latency_p99 / 1000000 | . * 100 | floor / 100)ms | \(.errors) |"' >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
            fi
          done

      - name: Post PR Comment with Results
        if: success()
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          C2_URL="${{ needs.deploy-pr-c2.outputs.c2_url }}"
          RUN_ID="${{ steps.start.outputs.run_id }}"
          MODE="${{ steps.mode.outputs.mode }}"
          PR_NUMBER="${{ github.event.pull_request.number }}"

          # Fetch status to get worker info
          STATUS_RESPONSE=$(curl -sf \
            -H "X-API-Key: ${{ secrets.C2_API_KEY }}" \
            "$C2_URL/api/benchmark/$RUN_ID/status" || echo '{}')

          # Build comment body
          COMMENT="## Benchmark Results - ${MODE^^} Mode\n\n"
          COMMENT+="**Run ID:** \`$RUN_ID\`\n"
          COMMENT+="**Status:** ${{ steps.results.outputs.status }}\n"
          COMMENT+="**C2:** PR-specific (built from this PR's code)\n\n"

          # Add worker placement info
          COMMENT+="### Worker Placement\n\n"
          COMMENT+="| Architecture | Role | Instance Type | Region | AZ |\n"
          COMMENT+="|--------------|------|---------------|--------|-----|\n"

          for arch in arm64 x86; do
            for role in server client; do
              KEY="${arch}-${role}"
              WORKER=$(echo "$STATUS_RESPONSE" | jq -r ".workers[\"$KEY\"] // {}")
              if [[ "$WORKER" != "{}" && "$WORKER" != "null" ]]; then
                W_TYPE=$(echo "$WORKER" | jq -r '.instance_type // "-"')
                W_REGION=$(echo "$WORKER" | jq -r '.region // "-"')
                W_AZ=$(echo "$WORKER" | jq -r '.az // "-"')
                COMMENT+="| $arch | $role | \`$W_TYPE\` | $W_REGION | $W_AZ |\n"
              fi
            done
          done
          COMMENT+="\n"

          for arch in arm64 x86; do
            ARCH_RESULTS=$(jq -r ".$arch // {}" results.json)
            BENCHMARKS=$(echo "$ARCH_RESULTS" | jq -r '.benchmarks // []')
            COUNT=$(echo "$BENCHMARKS" | jq 'length')

            if [[ "$COUNT" -gt 0 ]]; then
              COMMENT+="### $arch Results\n\n"
              COMMENT+="| Server | Req/sec | Avg Latency | P99 Latency | Errors |\n"
              COMMENT+="|--------|---------|-------------|-------------|--------|\n"

              while IFS= read -r row; do
                COMMENT+="$row\n"
              done < <(echo "$BENCHMARKS" | jq -r '.[] | "| \(.server_type) | \(.requests_per_sec | floor) | \(.latency_avg / 1000000 | . * 100 | floor / 100)ms | \(.latency_p99 / 1000000 | . * 100 | floor / 100)ms | \(.errors) |"')

              COMMENT+="\n"
            fi
          done

          # Delete previous benchmark comments (if any)
          gh api "repos/${{ github.repository }}/issues/${PR_NUMBER}/comments" \
            --jq '.[] | select(.user.login == "github-actions[bot]" and (.body | contains("Benchmark Results"))) | .id' \
            | xargs -I {} gh api -X DELETE "repos/${{ github.repository }}/issues/comments/{}" 2>/dev/null || true

          # Post new comment
          echo -e "$COMMENT" | gh pr comment "$PR_NUMBER" --body-file -
          echo "Posted results to PR #$PR_NUMBER"

      - name: Get Results Summary (Fallback)
        if: failure()
        run: |
          C2_URL="${{ needs.deploy-pr-c2.outputs.c2_url }}"
          RUN_ID="${{ steps.start.outputs.run_id }}"
          if [[ -z "$RUN_ID" ]]; then
            echo "No run ID available"
            exit 0
          fi

          RESPONSE=$(curl -sf \
            -H "X-API-Key: ${{ secrets.C2_API_KEY }}" \
            "$C2_URL/api/benchmark/$RUN_ID/status" || echo '{}')

          echo "## Benchmark Results (Partial)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Run ID:** $RUN_ID" >> $GITHUB_STEP_SUMMARY
          echo "**Status:** $(echo "$RESPONSE" | jq -r '.status // "unknown"')" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Error:** $(echo "$RESPONSE" | jq -r '.error // "Benchmark did not complete successfully"')" >> $GITHUB_STEP_SUMMARY

      - name: Cancel Benchmark on Workflow Cancellation
        if: cancelled()
        run: |
          C2_URL="${{ needs.deploy-pr-c2.outputs.c2_url }}"
          RUN_ID="${{ steps.start.outputs.run_id }}"
          if [[ -z "$RUN_ID" ]]; then
            echo "No run ID to cancel"
            exit 0
          fi

          echo "Workflow cancelled - sending cancel request to C2 for run $RUN_ID..."

          RESPONSE=$(curl -sf -X POST \
            -H "X-API-Key: ${{ secrets.C2_API_KEY }}" \
            "$C2_URL/api/benchmark/$RUN_ID/cancel" || echo '{"error":"failed to cancel"}')

          echo "Cancel response: $RESPONSE"

          # Also add to summary
          echo "## Benchmark Cancelled" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Run ID:** $RUN_ID" >> $GITHUB_STEP_SUMMARY
          echo "Benchmark was cancelled. Workers are being terminated." >> $GITHUB_STEP_SUMMARY

  # Cleanup PR C2 after benchmark completes (success or failure)
  cleanup-pr-c2:
    name: Cleanup PR C2
    runs-on: ubuntu-latest
    needs: [deploy-pr-c2, benchmark]
    if: always()

    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Delete PR C2 Stack
        run: |
          STACK_NAME="${{ needs.deploy-pr-c2.outputs.stack_name }}"
          if [[ -z "$STACK_NAME" ]]; then
            echo "No stack to delete"
            exit 0
          fi

          echo "Deleting PR C2 stack: $STACK_NAME"

          aws cloudformation delete-stack --stack-name "$STACK_NAME"
          echo "Stack deletion initiated"

          # Wait for deletion (with timeout)
          echo "Waiting for stack deletion..."
          aws cloudformation wait stack-delete-complete --stack-name "$STACK_NAME" || true

          echo "PR C2 cleanup complete"

      - name: Cleanup S3 Artifacts
        run: |
          PR_NUMBER="${{ github.event.pull_request.number }}"
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          BUCKET="celeris-artifacts-${AWS_ACCOUNT_ID}"

          echo "Cleaning up S3 artifacts for PR #$PR_NUMBER..."
          aws s3 rm "s3://${BUCKET}/pr-c2/pr-${PR_NUMBER}/" --recursive || true
          echo "S3 cleanup complete"
