name: Benchmark (Metal)

# Metal mode: Official benchmarks on bare-metal instances
# Each architecture falls back independently to provisional if quota unavailable
#
# Launch Priority (spot first for cost savings, on-demand fallback):
#   ARM64: Metal Spot -> Metal On-Demand -> Provisional Spot -> Provisional On-Demand
#   x86:   Metal Spot -> Metal On-Demand -> Provisional Spot -> Provisional On-Demand
#
# Instance Types:
#   ARM64: c6g.metal (official) or c6g.2xlarge (provisional)
#   x86:   c5.metal (official) or c5.2xlarge (provisional)
#
# If spot instance is terminated mid-benchmark, automatically retries with checkpoint
#
# Results are stored with -provisional suffix if not on metal:
#   results/latest/arm64/          (official)
#   results/latest/x86-provisional/ (provisional)
#
# Security: Only authorized users can trigger (to protect AWS resources)

on:
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      duration:
        description: "Benchmark duration (e.g., 30s, 60s)"
        required: false
        default: "30s"
      benchmark_mode:
        description: "Benchmark servers to test"
        required: false
        default: "all"
        type: choice
        options:
          - baseline
          - theoretical
          - all

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

env:
  TF_VAR_repository_url: ${{ github.server_url }}/${{ github.repository }}
  AWS_REGION: us-east-1

jobs:
  authorize:
    name: Authorize Caller
    runs-on: ubuntu-latest
    outputs:
      authorized: ${{ steps.check.outputs.authorized }}
    steps:
      - name: Check Permissions
        id: check
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          if [[ "${{ github.event_name }}" == "release" ]]; then
            echo "authorized=true" >> $GITHUB_OUTPUT
            echo "Release event - authorized (release creator: ${{ github.actor }})"
          elif [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            PERMISSION=$(gh api repos/${{ github.repository }}/collaborators/${{ github.actor }}/permission --jq '.permission')
            echo "User: ${{ github.actor }}"
            echo "Permission level: $PERMISSION"
            if [[ "$PERMISSION" == "admin" || "$PERMISSION" == "maintain" || "$PERMISSION" == "write" ]]; then
              echo "authorized=true" >> $GITHUB_OUTPUT
              echo "User ${{ github.actor }} authorized with permission: $PERMISSION"
            else
              echo "authorized=false" >> $GITHUB_OUTPUT
              echo "::error::Unauthorized: Only maintainers and owners can trigger metal benchmarks"
              exit 1
            fi
          else
            echo "authorized=false" >> $GITHUB_OUTPUT
            exit 1
          fi

  # Pre-flight checks: list existing instances and cleanup orphans
  preflight:
    name: Pre-flight Checks
    runs-on: ubuntu-latest
    needs: authorize
    if: needs.authorize.outputs.authorized == 'true'

    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v5
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Check Existing Instances
        run: |
          echo "## Pre-flight Check: Existing Instances" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          INSTANCES=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=benchmark-runner-*" \
                      "Name=instance-state-name,Values=pending,running" \
            --query 'Reservations[].Instances[].[InstanceId,InstanceType,State.Name,LaunchTime,Tags[?Key==`Name`].Value|[0]]' \
            --output text)

          if [ -z "$INSTANCES" ]; then
            echo "No existing benchmark instances found. Ready to launch." >> $GITHUB_STEP_SUMMARY
          else
            echo "**WARNING: Found existing benchmark instances:**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| Instance ID | Type | State | Launched | Name |" >> $GITHUB_STEP_SUMMARY
            echo "|-------------|------|-------|----------|------|" >> $GITHUB_STEP_SUMMARY
            echo "$INSTANCES" | while read id type state launched name; do
              echo "| $id | $type | $state | $launched | $name |" >> $GITHUB_STEP_SUMMARY
            done
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "These may be orphaned from a previous run. Consider running the **Cleanup Instances** workflow if issues occur." >> $GITHUB_STEP_SUMMARY
          fi

      - name: Check Self-Hosted Runners
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_RUNNER_TOKEN }}
        run: |
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Pre-flight Check: Self-Hosted Runners" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          RUNNERS=$(gh api repos/${{ github.repository }}/actions/runners --jq '.runners[] | "\(.name) \(.status) \(.busy)"')

          if [ -z "$RUNNERS" ]; then
            echo "No self-hosted runners registered." >> $GITHUB_STEP_SUMMARY
          else
            echo "| Runner Name | Status | Busy |" >> $GITHUB_STEP_SUMMARY
            echo "|-------------|--------|------|" >> $GITHUB_STEP_SUMMARY
            echo "$RUNNERS" | while read name status busy; do
              echo "| $name | $status | $busy |" >> $GITHUB_STEP_SUMMARY
            done
          fi

          # Count offline runners
          OFFLINE=$(gh api repos/${{ github.repository }}/actions/runners --jq '[.runners[] | select(.status == "offline")] | length')
          if [ "$OFFLINE" -gt 0 ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Note:** $OFFLINE offline runner(s) found. These will be cleaned up after the benchmark." >> $GITHUB_STEP_SUMMARY
          fi

  # Launch ARM64 infrastructure with independent fallback
  launch-arm64:
    name: Launch ARM64 Infrastructure
    runs-on: ubuntu-latest
    needs: [authorize, preflight]
    if: needs.authorize.outputs.authorized == 'true'
    outputs:
      launched: ${{ steps.result.outputs.launched }}
      is_provisional: ${{ steps.result.outputs.is_provisional }}
      instance_type: ${{ steps.result.outputs.instance_type }}
      server_runner_label: ${{ steps.result.outputs.server_runner_label }}
      client_runner_label: ${{ steps.result.outputs.client_runner_label }}
      server_private_ip: ${{ steps.result.outputs.server_private_ip }}
      was_spot: ${{ steps.result.outputs.was_spot }}
      benchmark_mode: ${{ steps.result.outputs.benchmark_mode }}

    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.6.0"
          terraform_wrapper: false

      - name: Terraform Init
        working-directory: terraform
        run: terraform init

      # ARM64 Priority: Spot first (cost savings), On-Demand fallback
      # Order: Metal Spot -> Metal On-Demand -> Provisional Spot -> Provisional On-Demand

      # Try Metal Spot first
      - name: Try ARM64 Metal Spot
        id: metal_spot
        continue-on-error: true
        working-directory: terraform
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          TF_VAR_gh_pat_runner_token: ${{ secrets.GH_PAT_RUNNER_TOKEN }}
          TF_VAR_benchmark_mode: metal
          TF_VAR_launch_arm64_only: "true"
        run: |
          echo "Attempting ARM64 metal spot (c6g.metal)..."
          set +e
          terraform apply -auto-approve -target=aws_spot_instance_request.arm64_server
          EXIT_CODE=$?
          set -e
          if [ $EXIT_CODE -eq 0 ]; then
            echo "success=true" >> $GITHUB_OUTPUT
            echo "ARM64 metal spot launched successfully"
          else
            echo "success=false" >> $GITHUB_OUTPUT
            echo "ARM64 metal spot failed with exit code $EXIT_CODE"
          fi

      # Try Metal On-Demand
      - name: Cleanup ARM64 Metal Spot
        if: steps.metal_spot.outputs.success != 'true'
        working-directory: terraform
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          TF_VAR_gh_pat_runner_token: ${{ secrets.GH_PAT_RUNNER_TOKEN }}
          TF_VAR_benchmark_mode: metal
          TF_VAR_launch_arm64_only: "true"
        run: terraform destroy -auto-approve -target=aws_spot_instance_request.arm64_server || true

      - name: Try ARM64 Metal On-Demand
        id: metal_ondemand
        if: steps.metal_spot.outputs.success != 'true'
        continue-on-error: true
        working-directory: terraform
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          TF_VAR_gh_pat_runner_token: ${{ secrets.GH_PAT_RUNNER_TOKEN }}
          TF_VAR_benchmark_mode: metal
          TF_VAR_use_on_demand: "true"
          TF_VAR_launch_arm64_only: "true"
        run: |
          echo "Attempting ARM64 metal on-demand (c6g.metal)..."
          set +e
          terraform apply -auto-approve -target=aws_instance.arm64_server_ondemand
          EXIT_CODE=$?
          set -e
          if [ $EXIT_CODE -eq 0 ]; then
            echo "success=true" >> $GITHUB_OUTPUT
            echo "ARM64 metal on-demand launched successfully"
          else
            echo "success=false" >> $GITHUB_OUTPUT
            echo "ARM64 metal on-demand failed with exit code $EXIT_CODE"
          fi

      # Try Provisional Spot
      - name: Cleanup ARM64 Metal On-Demand
        if: steps.metal_spot.outputs.success != 'true' && steps.metal_ondemand.outputs.success != 'true'
        working-directory: terraform
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          TF_VAR_gh_pat_runner_token: ${{ secrets.GH_PAT_RUNNER_TOKEN }}
          TF_VAR_benchmark_mode: metal
          TF_VAR_use_on_demand: "true"
          TF_VAR_launch_arm64_only: "true"
        run: terraform destroy -auto-approve || true

      - name: Try ARM64 Provisional Spot
        id: provisional_spot
        if: steps.metal_spot.outputs.success != 'true' && steps.metal_ondemand.outputs.success != 'true'
        continue-on-error: true
        working-directory: terraform
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          TF_VAR_gh_pat_runner_token: ${{ secrets.GH_PAT_RUNNER_TOKEN }}
          TF_VAR_benchmark_mode: provisional
          TF_VAR_launch_arm64_only: "true"
        run: |
          echo "Attempting ARM64 provisional spot (c6g.2xlarge)..."
          set +e
          terraform apply -auto-approve -target=aws_spot_instance_request.arm64_server
          EXIT_CODE=$?
          set -e
          if [ $EXIT_CODE -eq 0 ]; then
            echo "success=true" >> $GITHUB_OUTPUT
            echo "ARM64 provisional spot launched successfully"
          else
            echo "success=false" >> $GITHUB_OUTPUT
            echo "ARM64 provisional spot failed with exit code $EXIT_CODE"
          fi

      # Try Provisional On-Demand
      - name: Cleanup ARM64 Provisional Spot
        if: steps.metal_spot.outputs.success != 'true' && steps.metal_ondemand.outputs.success != 'true' && steps.provisional_spot.outputs.success != 'true'
        working-directory: terraform
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          TF_VAR_gh_pat_runner_token: ${{ secrets.GH_PAT_RUNNER_TOKEN }}
          TF_VAR_benchmark_mode: provisional
          TF_VAR_launch_arm64_only: "true"
        run: terraform destroy -auto-approve || true

      - name: Try ARM64 Provisional On-Demand
        id: provisional_ondemand
        if: steps.metal_spot.outputs.success != 'true' && steps.metal_ondemand.outputs.success != 'true' && steps.provisional_spot.outputs.success != 'true'
        continue-on-error: true
        working-directory: terraform
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          TF_VAR_gh_pat_runner_token: ${{ secrets.GH_PAT_RUNNER_TOKEN }}
          TF_VAR_benchmark_mode: provisional
          TF_VAR_use_on_demand: "true"
          TF_VAR_launch_arm64_only: "true"
        run: |
          echo "Attempting ARM64 provisional on-demand (c6g.2xlarge)..."
          set +e
          terraform apply -auto-approve -target=aws_instance.arm64_server_ondemand
          EXIT_CODE=$?
          set -e
          if [ $EXIT_CODE -eq 0 ]; then
            echo "success=true" >> $GITHUB_OUTPUT
            echo "ARM64 provisional on-demand launched successfully"
          else
            echo "success=false" >> $GITHUB_OUTPUT
            echo "ARM64 provisional on-demand failed with exit code $EXIT_CODE"
          fi

      - name: Set ARM64 Launch Results
        id: result
        working-directory: terraform
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          TF_VAR_gh_pat_runner_token: ${{ secrets.GH_PAT_RUNNER_TOKEN }}
        run: |
          # Priority order: metal_spot -> metal_ondemand -> provisional_spot -> provisional_ondemand
          if [[ "${{ steps.metal_spot.outputs.success }}" == "true" ]]; then
            echo "launched=true" >> $GITHUB_OUTPUT
            echo "is_provisional=false" >> $GITHUB_OUTPUT
            echo "instance_type=c6g.metal-spot" >> $GITHUB_OUTPUT
            echo "server_runner_label=server-metal-arm64" >> $GITHUB_OUTPUT
            echo "client_runner_label=client-metal-arm64" >> $GITHUB_OUTPUT
            echo "was_spot=true" >> $GITHUB_OUTPUT
            echo "benchmark_mode=metal" >> $GITHUB_OUTPUT
          elif [[ "${{ steps.metal_ondemand.outputs.success }}" == "true" ]]; then
            echo "launched=true" >> $GITHUB_OUTPUT
            echo "is_provisional=false" >> $GITHUB_OUTPUT
            echo "instance_type=c6g.metal-ondemand" >> $GITHUB_OUTPUT
            echo "server_runner_label=server-metal-arm64" >> $GITHUB_OUTPUT
            echo "client_runner_label=client-metal-arm64" >> $GITHUB_OUTPUT
            echo "was_spot=false" >> $GITHUB_OUTPUT
            echo "benchmark_mode=metal" >> $GITHUB_OUTPUT
          elif [[ "${{ steps.provisional_spot.outputs.success }}" == "true" ]]; then
            echo "launched=true" >> $GITHUB_OUTPUT
            echo "is_provisional=true" >> $GITHUB_OUTPUT
            echo "instance_type=c6g.2xlarge-spot" >> $GITHUB_OUTPUT
            echo "server_runner_label=server-provisional-arm64" >> $GITHUB_OUTPUT
            echo "client_runner_label=client-provisional-arm64" >> $GITHUB_OUTPUT
            echo "was_spot=true" >> $GITHUB_OUTPUT
            echo "benchmark_mode=provisional" >> $GITHUB_OUTPUT
          elif [[ "${{ steps.provisional_ondemand.outputs.success }}" == "true" ]]; then
            echo "launched=true" >> $GITHUB_OUTPUT
            echo "is_provisional=true" >> $GITHUB_OUTPUT
            echo "instance_type=c6g.2xlarge-ondemand" >> $GITHUB_OUTPUT
            echo "server_runner_label=server-provisional-arm64" >> $GITHUB_OUTPUT
            echo "client_runner_label=client-provisional-arm64" >> $GITHUB_OUTPUT
            echo "was_spot=false" >> $GITHUB_OUTPUT
            echo "benchmark_mode=provisional" >> $GITHUB_OUTPUT
          else
            echo "launched=false" >> $GITHUB_OUTPUT
            echo "is_provisional=false" >> $GITHUB_OUTPUT
            echo "instance_type=none" >> $GITHUB_OUTPUT
            echo "was_spot=false" >> $GITHUB_OUTPUT
            echo "::error::All ARM64 launch attempts failed"
            exit 0
          fi

          # Get server private IP from terraform output
          SERVER_IP=$(terraform output -raw arm64_server_private_ip 2>/dev/null || echo "")
          if [ -n "$SERVER_IP" ] && [ "$SERVER_IP" != "null" ]; then
            echo "server_private_ip=$SERVER_IP" >> $GITHUB_OUTPUT
            echo "Server private IP: $SERVER_IP"
          else
            echo "::warning::Could not get server private IP"
            echo "server_private_ip=" >> $GITHUB_OUTPUT
          fi

      - name: Launch ARM64 Client
        if: steps.result.outputs.launched == 'true' && steps.result.outputs.server_private_ip != ''
        working-directory: terraform
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          TF_VAR_gh_pat_runner_token: ${{ secrets.GH_PAT_RUNNER_TOKEN }}
          TF_VAR_benchmark_mode: ${{ steps.result.outputs.benchmark_mode }}
          TF_VAR_launch_arm64_only: "true"
          TF_VAR_launch_client: "true"
          TF_VAR_server_ip_arm64: ${{ steps.result.outputs.server_private_ip }}
        run: |
          echo "Launching ARM64 client instance (server IP: $TF_VAR_server_ip_arm64)..."
          terraform apply -auto-approve -target=aws_instance.arm64_client
          echo "ARM64 client launched"

      - name: Wait for ARM64 Runners
        if: steps.result.outputs.launched == 'true'
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_RUNNER_TOKEN }}
        run: |
          if [[ "${{ steps.result.outputs.is_provisional }}" == "true" ]]; then
            echo "Waiting for ARM64 provisional runners (90s)..."
            sleep 90
          else
            echo "Waiting for ARM64 metal runners (150s)..."
            sleep 150
          fi

          # Debug: Show expected labels
          echo ""
          echo "=== Expected Runner Labels ==="
          echo "Server job expects: [self-hosted, ${{ steps.result.outputs.server_runner_label }}]"
          echo "Client job expects: [self-hosted, ${{ steps.result.outputs.client_runner_label }}]"

          # Debug: Show registered runners
          echo ""
          echo "=== Currently Registered Runners ==="
          gh api repos/${{ github.repository }}/actions/runners \
            --jq '.runners[] | "Name: \(.name) | Status: \(.status) | Labels: \([.labels[].name] | join(", "))"' || echo "Failed to fetch runners"

      - name: Report Launch Status
        if: always()
        run: |
          echo "## ARM64 Launch Result" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [[ "${{ steps.result.outputs.launched }}" == "true" ]]; then
            if [[ "${{ steps.result.outputs.is_provisional }}" == "true" ]]; then
              echo "**Status:** Launched (PROVISIONAL)" >> $GITHUB_STEP_SUMMARY
            else
              echo "**Status:** Launched (Official Metal)" >> $GITHUB_STEP_SUMMARY
            fi
            echo "- Instance Type: \`${{ steps.result.outputs.instance_type }}\`" >> $GITHUB_STEP_SUMMARY
            echo "- Server Label: \`${{ steps.result.outputs.server_runner_label }}\`" >> $GITHUB_STEP_SUMMARY
            echo "- Client Label: \`${{ steps.result.outputs.client_runner_label }}\`" >> $GITHUB_STEP_SUMMARY
            echo "- Server IP: \`${{ steps.result.outputs.server_private_ip }}\`" >> $GITHUB_STEP_SUMMARY
            echo "- Spot Instance: ${{ steps.result.outputs.was_spot }}" >> $GITHUB_STEP_SUMMARY
          else
            echo "**Status:** FAILED" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "All launch attempts failed. Check the logs above for details." >> $GITHUB_STEP_SUMMARY
          fi

  # Launch x86 infrastructure with independent fallback
  launch-x86:
    name: Launch x86 Infrastructure
    runs-on: ubuntu-latest
    needs: [authorize, preflight]
    if: needs.authorize.outputs.authorized == 'true'
    outputs:
      launched: ${{ steps.result.outputs.launched }}
      is_provisional: ${{ steps.result.outputs.is_provisional }}
      instance_type: ${{ steps.result.outputs.instance_type }}
      server_runner_label: ${{ steps.result.outputs.server_runner_label }}
      client_runner_label: ${{ steps.result.outputs.client_runner_label }}
      server_private_ip: ${{ steps.result.outputs.server_private_ip }}
      was_spot: ${{ steps.result.outputs.was_spot }}
      benchmark_mode: ${{ steps.result.outputs.benchmark_mode }}

    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.6.0"
          terraform_wrapper: false

      - name: Terraform Init
        working-directory: terraform
        run: terraform init

      # Try Metal Spot
      - name: Try x86 Metal Spot
        id: metal_spot
        continue-on-error: true
        working-directory: terraform
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          TF_VAR_gh_pat_runner_token: ${{ secrets.GH_PAT_RUNNER_TOKEN }}
          TF_VAR_benchmark_mode: metal
          TF_VAR_launch_x86_only: "true"
        run: |
          echo "Attempting x86 metal spot (c5.metal)..."
          set +e
          terraform apply -auto-approve -target=aws_spot_instance_request.x86_server
          EXIT_CODE=$?
          set -e
          if [ $EXIT_CODE -eq 0 ]; then
            echo "success=true" >> $GITHUB_OUTPUT
            echo "x86 metal spot launched successfully"
          else
            echo "success=false" >> $GITHUB_OUTPUT
            echo "x86 metal spot failed with exit code $EXIT_CODE"
          fi

      # Try Metal On-Demand
      - name: Cleanup x86 Metal Spot
        if: steps.metal_spot.outputs.success != 'true'
        working-directory: terraform
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          TF_VAR_gh_pat_runner_token: ${{ secrets.GH_PAT_RUNNER_TOKEN }}
          TF_VAR_benchmark_mode: metal
          TF_VAR_launch_x86_only: "true"
        run: terraform destroy -auto-approve -target=aws_spot_instance_request.x86_server || true

      - name: Try x86 Metal On-Demand
        id: metal_ondemand
        if: steps.metal_spot.outputs.success != 'true'
        continue-on-error: true
        working-directory: terraform
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          TF_VAR_gh_pat_runner_token: ${{ secrets.GH_PAT_RUNNER_TOKEN }}
          TF_VAR_benchmark_mode: metal
          TF_VAR_use_on_demand: "true"
          TF_VAR_launch_x86_only: "true"
        run: |
          echo "Attempting x86 metal on-demand (c5.metal)..."
          set +e
          terraform apply -auto-approve -target=aws_instance.x86_server_ondemand
          EXIT_CODE=$?
          set -e
          if [ $EXIT_CODE -eq 0 ]; then
            echo "success=true" >> $GITHUB_OUTPUT
            echo "x86 metal on-demand launched successfully"
          else
            echo "success=false" >> $GITHUB_OUTPUT
            echo "x86 metal on-demand failed with exit code $EXIT_CODE"
          fi

      # Try Provisional Spot
      - name: Cleanup x86 Metal On-Demand
        if: steps.metal_spot.outputs.success != 'true' && steps.metal_ondemand.outputs.success != 'true'
        working-directory: terraform
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          TF_VAR_gh_pat_runner_token: ${{ secrets.GH_PAT_RUNNER_TOKEN }}
          TF_VAR_benchmark_mode: metal
          TF_VAR_use_on_demand: "true"
          TF_VAR_launch_x86_only: "true"
        run: terraform destroy -auto-approve || true

      - name: Try x86 Provisional Spot
        id: provisional_spot
        if: steps.metal_spot.outputs.success != 'true' && steps.metal_ondemand.outputs.success != 'true'
        continue-on-error: true
        working-directory: terraform
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          TF_VAR_gh_pat_runner_token: ${{ secrets.GH_PAT_RUNNER_TOKEN }}
          TF_VAR_benchmark_mode: provisional
          TF_VAR_launch_x86_only: "true"
        run: |
          echo "Attempting x86 provisional spot (c5.2xlarge)..."
          set +e
          terraform apply -auto-approve -target=aws_spot_instance_request.x86_server
          EXIT_CODE=$?
          set -e
          if [ $EXIT_CODE -eq 0 ]; then
            echo "success=true" >> $GITHUB_OUTPUT
            echo "x86 provisional spot launched successfully"
          else
            echo "success=false" >> $GITHUB_OUTPUT
            echo "x86 provisional spot failed with exit code $EXIT_CODE"
          fi

      # Try Provisional On-Demand
      - name: Cleanup x86 Provisional Spot
        if: steps.metal_spot.outputs.success != 'true' && steps.metal_ondemand.outputs.success != 'true' && steps.provisional_spot.outputs.success != 'true'
        working-directory: terraform
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          TF_VAR_gh_pat_runner_token: ${{ secrets.GH_PAT_RUNNER_TOKEN }}
          TF_VAR_benchmark_mode: provisional
          TF_VAR_launch_x86_only: "true"
        run: terraform destroy -auto-approve || true

      - name: Try x86 Provisional On-Demand
        id: provisional_ondemand
        if: steps.metal_spot.outputs.success != 'true' && steps.metal_ondemand.outputs.success != 'true' && steps.provisional_spot.outputs.success != 'true'
        continue-on-error: true
        working-directory: terraform
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          TF_VAR_gh_pat_runner_token: ${{ secrets.GH_PAT_RUNNER_TOKEN }}
          TF_VAR_benchmark_mode: provisional
          TF_VAR_use_on_demand: "true"
          TF_VAR_launch_x86_only: "true"
        run: |
          echo "Attempting x86 provisional on-demand (c5.2xlarge)..."
          set +e
          terraform apply -auto-approve -target=aws_instance.x86_server_ondemand
          EXIT_CODE=$?
          set -e
          if [ $EXIT_CODE -eq 0 ]; then
            echo "success=true" >> $GITHUB_OUTPUT
            echo "x86 provisional on-demand launched successfully"
          else
            echo "success=false" >> $GITHUB_OUTPUT
            echo "x86 provisional on-demand failed with exit code $EXIT_CODE"
          fi

      - name: Set x86 Launch Results
        id: result
        working-directory: terraform
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          TF_VAR_gh_pat_runner_token: ${{ secrets.GH_PAT_RUNNER_TOKEN }}
        run: |
          if [[ "${{ steps.metal_spot.outputs.success }}" == "true" ]]; then
            echo "launched=true" >> $GITHUB_OUTPUT
            echo "is_provisional=false" >> $GITHUB_OUTPUT
            echo "instance_type=c5.metal-spot" >> $GITHUB_OUTPUT
            echo "server_runner_label=server-metal-x86" >> $GITHUB_OUTPUT
            echo "client_runner_label=client-metal-x86" >> $GITHUB_OUTPUT
            echo "was_spot=true" >> $GITHUB_OUTPUT
            echo "benchmark_mode=metal" >> $GITHUB_OUTPUT
          elif [[ "${{ steps.metal_ondemand.outputs.success }}" == "true" ]]; then
            echo "launched=true" >> $GITHUB_OUTPUT
            echo "is_provisional=false" >> $GITHUB_OUTPUT
            echo "instance_type=c5.metal-ondemand" >> $GITHUB_OUTPUT
            echo "server_runner_label=server-metal-x86" >> $GITHUB_OUTPUT
            echo "client_runner_label=client-metal-x86" >> $GITHUB_OUTPUT
            echo "was_spot=false" >> $GITHUB_OUTPUT
            echo "benchmark_mode=metal" >> $GITHUB_OUTPUT
          elif [[ "${{ steps.provisional_spot.outputs.success }}" == "true" ]]; then
            echo "launched=true" >> $GITHUB_OUTPUT
            echo "is_provisional=true" >> $GITHUB_OUTPUT
            echo "instance_type=c5.2xlarge-spot" >> $GITHUB_OUTPUT
            echo "server_runner_label=server-provisional-x86" >> $GITHUB_OUTPUT
            echo "client_runner_label=client-provisional-x86" >> $GITHUB_OUTPUT
            echo "was_spot=true" >> $GITHUB_OUTPUT
            echo "benchmark_mode=provisional" >> $GITHUB_OUTPUT
          elif [[ "${{ steps.provisional_ondemand.outputs.success }}" == "true" ]]; then
            echo "launched=true" >> $GITHUB_OUTPUT
            echo "is_provisional=true" >> $GITHUB_OUTPUT
            echo "instance_type=c5.2xlarge-ondemand" >> $GITHUB_OUTPUT
            echo "server_runner_label=server-provisional-x86" >> $GITHUB_OUTPUT
            echo "client_runner_label=client-provisional-x86" >> $GITHUB_OUTPUT
            echo "was_spot=false" >> $GITHUB_OUTPUT
            echo "benchmark_mode=provisional" >> $GITHUB_OUTPUT
          else
            echo "launched=false" >> $GITHUB_OUTPUT
            echo "is_provisional=false" >> $GITHUB_OUTPUT
            echo "instance_type=none" >> $GITHUB_OUTPUT
            echo "was_spot=false" >> $GITHUB_OUTPUT
            echo "::error::All x86 launch attempts failed"
            exit 0
          fi

          # Get server private IP from terraform output
          SERVER_IP=$(terraform output -raw x86_server_private_ip 2>/dev/null || echo "")
          if [ -n "$SERVER_IP" ] && [ "$SERVER_IP" != "null" ]; then
            echo "server_private_ip=$SERVER_IP" >> $GITHUB_OUTPUT
            echo "Server private IP: $SERVER_IP"
          else
            echo "::warning::Could not get server private IP"
            echo "server_private_ip=" >> $GITHUB_OUTPUT
          fi

      - name: Launch x86 Client
        if: steps.result.outputs.launched == 'true' && steps.result.outputs.server_private_ip != ''
        working-directory: terraform
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          TF_VAR_gh_pat_runner_token: ${{ secrets.GH_PAT_RUNNER_TOKEN }}
          TF_VAR_benchmark_mode: ${{ steps.result.outputs.benchmark_mode }}
          TF_VAR_launch_x86_only: "true"
          TF_VAR_launch_client: "true"
          TF_VAR_server_ip_x86: ${{ steps.result.outputs.server_private_ip }}
        run: |
          echo "Launching x86 client instance (server IP: $TF_VAR_server_ip_x86)..."
          terraform apply -auto-approve -target=aws_instance.x86_client
          echo "x86 client launched"

      - name: Wait for x86 Runners
        if: steps.result.outputs.launched == 'true'
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_RUNNER_TOKEN }}
        run: |
          if [[ "${{ steps.result.outputs.is_provisional }}" == "true" ]]; then
            echo "Waiting for x86 provisional runners (90s)..."
            sleep 90
          else
            echo "Waiting for x86 metal runners (150s)..."
            sleep 150
          fi

          # Debug: Show expected labels
          echo ""
          echo "=== Expected Runner Labels ==="
          echo "Server job expects: [self-hosted, ${{ steps.result.outputs.server_runner_label }}]"
          echo "Client job expects: [self-hosted, ${{ steps.result.outputs.client_runner_label }}]"

          # Debug: Show registered runners
          echo ""
          echo "=== Currently Registered Runners ==="
          gh api repos/${{ github.repository }}/actions/runners \
            --jq '.runners[] | "Name: \(.name) | Status: \(.status) | Labels: \([.labels[].name] | join(", "))"' || echo "Failed to fetch runners"

      - name: Report Launch Status
        if: always()
        run: |
          echo "## x86 Launch Result" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [[ "${{ steps.result.outputs.launched }}" == "true" ]]; then
            if [[ "${{ steps.result.outputs.is_provisional }}" == "true" ]]; then
              echo "**Status:** Launched (PROVISIONAL)" >> $GITHUB_STEP_SUMMARY
            else
              echo "**Status:** Launched (Official Metal)" >> $GITHUB_STEP_SUMMARY
            fi
            echo "- Instance Type: \`${{ steps.result.outputs.instance_type }}\`" >> $GITHUB_STEP_SUMMARY
            echo "- Server Label: \`${{ steps.result.outputs.server_runner_label }}\`" >> $GITHUB_STEP_SUMMARY
            echo "- Client Label: \`${{ steps.result.outputs.client_runner_label }}\`" >> $GITHUB_STEP_SUMMARY
            echo "- Server IP: \`${{ steps.result.outputs.server_private_ip }}\`" >> $GITHUB_STEP_SUMMARY
            echo "- Spot Instance: ${{ steps.result.outputs.was_spot }}" >> $GITHUB_STEP_SUMMARY
          else
            echo "**Status:** FAILED" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "All launch attempts failed. Check the logs above for details." >> $GITHUB_STEP_SUMMARY
          fi

  # Server job: Runs on server instance, provides control daemon for benchmarking
  server-arm64:
    name: Server (ARM64)
    needs: launch-arm64
    if: needs.launch-arm64.outputs.launched == 'true'
    runs-on: [self-hosted, "${{ needs.launch-arm64.outputs.server_runner_label }}"]
    timeout-minutes: 120

    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: "1.25.5"

      - name: Build Server and Control Daemon
        run: |
          go mod download
          go build -o bin/server ./cmd/server
          go build -o bin/control ./cmd/control
          echo "Server and control daemon built"

      - name: Run Control Daemon
        env:
          IS_PROVISIONAL: ${{ needs.launch-arm64.outputs.is_provisional }}
          INSTANCE_TYPE: ${{ needs.launch-arm64.outputs.instance_type }}
        run: |
          if [[ "$IS_PROVISIONAL" == "true" ]]; then
            echo "Running PROVISIONAL server on $INSTANCE_TYPE"
          else
            echo "Running OFFICIAL metal server on $INSTANCE_TYPE"
          fi
          # Control daemon will manage server processes as requested by client
          # It runs until the client job completes (detected by timeout or explicit shutdown)
          ./bin/control -control-port 9999 -server-port 8080

  # Client job: Runs on client instance, executes benchmarks against server
  # Note: Does NOT depend on server-arm64 completing - they run in parallel
  benchmark-arm64:
    name: Benchmark (ARM64)
    needs: launch-arm64
    if: |
      needs.launch-arm64.outputs.launched == 'true' &&
      needs.launch-arm64.outputs.server_private_ip != ''
    runs-on: [self-hosted, "${{ needs.launch-arm64.outputs.client_runner_label }}"]
    timeout-minutes: 90

    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: "1.25.5"

      - name: Build Benchmark Tool
        run: |
          go mod download
          go build -o bin/bench ./cmd/bench
          echo "Benchmark tool built"

      - name: Run Benchmarks
        env:
          BENCHMARK_DURATION: ${{ github.event.inputs.duration || '30s' }}
          BENCHMARK_MODE: ${{ github.event.inputs.benchmark_mode || 'all' }}
          IS_PROVISIONAL: ${{ needs.launch-arm64.outputs.is_provisional }}
          INSTANCE_TYPE: ${{ needs.launch-arm64.outputs.instance_type }}
          SERVER_IP: ${{ needs.launch-arm64.outputs.server_private_ip }}
          AWS_REGION: us-east-1
        run: |
          if [[ "$IS_PROVISIONAL" == "true" ]]; then
            echo "Running PROVISIONAL benchmarks (server: $SERVER_IP, type: $INSTANCE_TYPE)"
          else
            echo "Running OFFICIAL metal benchmarks (server: $SERVER_IP, type: $INSTANCE_TYPE)"
          fi
          # Run benchmark in remote mode with SSM discovery for dynamic IP updates
          # SSM allows client to discover new server IP if spot instance is replaced
          ./bin/bench -mode "$BENCHMARK_MODE" -duration "$BENCHMARK_DURATION" \
            -server-ip "$SERVER_IP" -control-port 9999 -use-ssm -resume

      - name: Upload Results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: benchmark-results-arm64
          path: results/
          retention-days: 90
          if-no-files-found: ignore

  # Server job: Runs on server instance, provides control daemon for benchmarking
  server-x86:
    name: Server (x86)
    needs: launch-x86
    if: needs.launch-x86.outputs.launched == 'true'
    runs-on: [self-hosted, "${{ needs.launch-x86.outputs.server_runner_label }}"]
    timeout-minutes: 120

    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: "1.25.5"

      - name: Build Server and Control Daemon
        run: |
          go mod download
          go build -o bin/server ./cmd/server
          go build -o bin/control ./cmd/control
          echo "Server and control daemon built"

      - name: Run Control Daemon
        env:
          IS_PROVISIONAL: ${{ needs.launch-x86.outputs.is_provisional }}
          INSTANCE_TYPE: ${{ needs.launch-x86.outputs.instance_type }}
        run: |
          if [[ "$IS_PROVISIONAL" == "true" ]]; then
            echo "Running PROVISIONAL server on $INSTANCE_TYPE"
          else
            echo "Running OFFICIAL metal server on $INSTANCE_TYPE"
          fi
          # Control daemon will manage server processes as requested by client
          ./bin/control -control-port 9999 -server-port 8080

  # Client job: Runs on client instance, executes benchmarks against server
  # Note: Does NOT depend on server-x86 completing - they run in parallel
  benchmark-x86:
    name: Benchmark (x86)
    needs: launch-x86
    if: |
      needs.launch-x86.outputs.launched == 'true' &&
      needs.launch-x86.outputs.server_private_ip != ''
    runs-on: [self-hosted, "${{ needs.launch-x86.outputs.client_runner_label }}"]
    timeout-minutes: 90

    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: "1.25.5"

      - name: Build Benchmark Tool
        run: |
          go mod download
          go build -o bin/bench ./cmd/bench
          echo "Benchmark tool built"

      - name: Run Benchmarks
        env:
          BENCHMARK_DURATION: ${{ github.event.inputs.duration || '30s' }}
          BENCHMARK_MODE: ${{ github.event.inputs.benchmark_mode || 'all' }}
          IS_PROVISIONAL: ${{ needs.launch-x86.outputs.is_provisional }}
          INSTANCE_TYPE: ${{ needs.launch-x86.outputs.instance_type }}
          SERVER_IP: ${{ needs.launch-x86.outputs.server_private_ip }}
          AWS_REGION: us-east-1
        run: |
          if [[ "$IS_PROVISIONAL" == "true" ]]; then
            echo "Running PROVISIONAL benchmarks (server: $SERVER_IP, type: $INSTANCE_TYPE)"
          else
            echo "Running OFFICIAL metal benchmarks (server: $SERVER_IP, type: $INSTANCE_TYPE)"
          fi
          # Run benchmark in remote mode with SSM discovery for dynamic IP updates
          ./bin/bench -mode "$BENCHMARK_MODE" -duration "$BENCHMARK_DURATION" \
            -server-ip "$SERVER_IP" -control-port 9999 -use-ssm -resume

      - name: Upload Results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: benchmark-results-x86
          path: results/
          retention-days: 90
          if-no-files-found: ignore

  # Retry ARM64 on on-demand if spot was terminated
  retry-arm64:
    name: Retry ARM64 (On-Demand)
    needs: [authorize, launch-arm64, benchmark-arm64]
    runs-on: ubuntu-latest
    if: |
      always() &&
      needs.authorize.outputs.authorized == 'true' &&
      needs.launch-arm64.outputs.launched == 'true' &&
      needs.launch-arm64.outputs.was_spot == 'true' &&
      needs.benchmark-arm64.result == 'failure'
    outputs:
      launched: ${{ steps.result.outputs.launched }}
      is_provisional: ${{ steps.result.outputs.is_provisional }}
      instance_type: ${{ steps.result.outputs.instance_type }}
      runner_label: ${{ steps.result.outputs.runner_label }}

    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.6.0"
          terraform_wrapper: false

      - name: Terraform Init
        working-directory: terraform
        run: terraform init

      - name: Recover Checkpoint from Failed Instance
        id: recover
        continue-on-error: true
        working-directory: terraform
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          TF_VAR_gh_pat_runner_token: ${{ secrets.GH_PAT_RUNNER_TOKEN }}
          TF_VAR_benchmark_mode: ${{ needs.launch-arm64.outputs.benchmark_mode }}
          TF_VAR_launch_arm64_only: "true"
          TF_VAR_launch_client: "true"
          AWS_REGION: us-east-1
        run: |
          echo "Attempting to recover checkpoint from failed ARM64 instance..."

          # Refresh state and get instance ID from CLIENT instance (where benchmarks run in fast mode)
          terraform refresh -target=aws_instance.arm64_client 2>/dev/null || true
          INSTANCE_ID=$(terraform output -raw arm64_client_instance_id 2>/dev/null || echo "")

          if [ -z "$INSTANCE_ID" ] || [ "$INSTANCE_ID" == "null" ]; then
            echo "No instance ID found in terraform state"
            echo "recovered=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "Found instance: $INSTANCE_ID"

          # Check instance state
          STATE=$(aws ec2 describe-instances --instance-ids "$INSTANCE_ID" \
            --query 'Reservations[0].Instances[0].State.Name' --output text 2>/dev/null || echo "unknown")

          echo "Instance state: $STATE"

          if [ "$STATE" != "running" ] && [ "$STATE" != "stopping" ]; then
            echo "Instance not accessible (state: $STATE)"
            echo "recovered=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Try to retrieve checkpoint via SSM
          echo "Attempting SSM command to retrieve checkpoint..."

          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=["if [ -f /home/runner/work/benchmarks/benchmarks/results/checkpoint-arm64.json ]; then cat /home/runner/work/benchmarks/benchmarks/results/checkpoint-arm64.json | base64; else echo NO_CHECKPOINT; fi"]' \
            --output text --query 'Command.CommandId' 2>/dev/null || echo "")

          if [ -z "$COMMAND_ID" ]; then
            echo "Failed to send SSM command"
            echo "recovered=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "SSM Command ID: $COMMAND_ID"

          # Wait for command to complete (max 30 seconds)
          for i in {1..6}; do
            sleep 5
            STATUS=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "$INSTANCE_ID" \
              --query 'Status' --output text 2>/dev/null || echo "Pending")
            echo "Command status: $STATUS"
            if [ "$STATUS" == "Success" ] || [ "$STATUS" == "Failed" ]; then
              break
            fi
          done

          if [ "$STATUS" != "Success" ]; then
            echo "SSM command did not succeed (status: $STATUS)"
            echo "recovered=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Get command output
          OUTPUT=$(aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id "$INSTANCE_ID" \
            --query 'StandardOutputContent' --output text 2>/dev/null || echo "")

          if [ -z "$OUTPUT" ] || [ "$OUTPUT" == "NO_CHECKPOINT" ]; then
            echo "No checkpoint found on instance"
            echo "recovered=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Decode and save checkpoint
          mkdir -p ../recovered-checkpoint
          echo "$OUTPUT" | base64 -d > ../recovered-checkpoint/checkpoint-arm64.json

          if [ -s ../recovered-checkpoint/checkpoint-arm64.json ]; then
            echo "Checkpoint recovered successfully!"
            echo "recovered=true" >> $GITHUB_OUTPUT
            head -20 ../recovered-checkpoint/checkpoint-arm64.json
          else
            echo "Failed to decode checkpoint"
            echo "recovered=false" >> $GITHUB_OUTPUT
          fi

      - name: Upload Recovered Checkpoint
        if: steps.recover.outputs.recovered == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: recovered-checkpoint-arm64
          path: recovered-checkpoint/
          retention-days: 1

      - name: Cleanup Failed Spot Instance
        working-directory: terraform
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          TF_VAR_gh_pat_runner_token: ${{ secrets.GH_PAT_RUNNER_TOKEN }}
          TF_VAR_benchmark_mode: ${{ needs.launch-arm64.outputs.benchmark_mode }}
          TF_VAR_launch_arm64_only: "true"
        run: |
          echo "Cleaning up failed ARM64 spot instance..."
          terraform destroy -auto-approve || true

      - name: Launch ARM64 On-Demand
        id: launch
        working-directory: terraform
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          TF_VAR_gh_pat_runner_token: ${{ secrets.GH_PAT_RUNNER_TOKEN }}
          TF_VAR_benchmark_mode: ${{ needs.launch-arm64.outputs.benchmark_mode }}
          TF_VAR_use_on_demand: "true"
          TF_VAR_launch_arm64_only: "true"
        run: |
          echo "Launching ARM64 on-demand for retry (mode: $TF_VAR_benchmark_mode)..."
          set +e
          terraform apply -auto-approve
          EXIT_CODE=$?
          set -e
          if [ $EXIT_CODE -eq 0 ]; then
            echo "success=true" >> $GITHUB_OUTPUT
            echo "ARM64 on-demand launched successfully for retry"
          else
            echo "success=false" >> $GITHUB_OUTPUT
            echo "ARM64 on-demand failed with exit code $EXIT_CODE"
          fi

      - name: Set Retry Results
        id: result
        env:
          ORIGINAL_PROVISIONAL: ${{ needs.launch-arm64.outputs.is_provisional }}
          ORIGINAL_MODE: ${{ needs.launch-arm64.outputs.benchmark_mode }}
        run: |
          if [[ "${{ steps.launch.outputs.success }}" == "true" ]]; then
            echo "launched=true" >> $GITHUB_OUTPUT
            echo "is_provisional=$ORIGINAL_PROVISIONAL" >> $GITHUB_OUTPUT
            if [[ "$ORIGINAL_MODE" == "metal" ]]; then
              echo "instance_type=c6g.metal-ondemand" >> $GITHUB_OUTPUT
              echo "runner_label=metal-arm64" >> $GITHUB_OUTPUT
            else
              echo "instance_type=c6g.2xlarge-ondemand" >> $GITHUB_OUTPUT
              echo "runner_label=provisional-arm64" >> $GITHUB_OUTPUT
            fi
          else
            echo "launched=false" >> $GITHUB_OUTPUT
            echo "::error::ARM64 on-demand retry launch failed"
          fi

      - name: Wait for ARM64 Runner
        if: steps.result.outputs.launched == 'true'
        env:
          ORIGINAL_PROVISIONAL: ${{ needs.launch-arm64.outputs.is_provisional }}
        run: |
          if [[ "$ORIGINAL_PROVISIONAL" == "true" ]]; then
            echo "Waiting for ARM64 provisional on-demand runner (60s)..."
            sleep 60
          else
            echo "Waiting for ARM64 metal on-demand runner (120s)..."
            sleep 120
          fi

  # Retry x86 on on-demand if spot was terminated
  retry-x86:
    name: Retry x86 (On-Demand)
    needs: [authorize, launch-x86, benchmark-x86]
    runs-on: ubuntu-latest
    if: |
      always() &&
      needs.authorize.outputs.authorized == 'true' &&
      needs.launch-x86.outputs.launched == 'true' &&
      needs.launch-x86.outputs.was_spot == 'true' &&
      needs.benchmark-x86.result == 'failure'
    outputs:
      launched: ${{ steps.result.outputs.launched }}
      is_provisional: ${{ steps.result.outputs.is_provisional }}
      instance_type: ${{ steps.result.outputs.instance_type }}
      runner_label: ${{ steps.result.outputs.runner_label }}

    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.6.0"
          terraform_wrapper: false

      - name: Terraform Init
        working-directory: terraform
        run: terraform init

      - name: Recover Checkpoint from Failed Instance
        id: recover
        continue-on-error: true
        working-directory: terraform
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          TF_VAR_gh_pat_runner_token: ${{ secrets.GH_PAT_RUNNER_TOKEN }}
          TF_VAR_benchmark_mode: ${{ needs.launch-x86.outputs.benchmark_mode }}
          TF_VAR_launch_x86_only: "true"
          TF_VAR_launch_client: "true"
          AWS_REGION: us-east-1
        run: |
          echo "Attempting to recover checkpoint from failed x86 instance..."

          # Refresh state and get instance ID from CLIENT instance (where benchmarks run in fast mode)
          terraform refresh -target=aws_instance.x86_client 2>/dev/null || true
          INSTANCE_ID=$(terraform output -raw x86_client_instance_id 2>/dev/null || echo "")

          if [ -z "$INSTANCE_ID" ] || [ "$INSTANCE_ID" == "null" ]; then
            echo "No instance ID found in terraform state"
            echo "recovered=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "Found instance: $INSTANCE_ID"

          # Check instance state
          STATE=$(aws ec2 describe-instances --instance-ids "$INSTANCE_ID" \
            --query 'Reservations[0].Instances[0].State.Name' --output text 2>/dev/null || echo "unknown")

          echo "Instance state: $STATE"

          if [ "$STATE" != "running" ] && [ "$STATE" != "stopping" ]; then
            echo "Instance not accessible (state: $STATE)"
            echo "recovered=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Try to retrieve checkpoint via SSM
          echo "Attempting SSM command to retrieve checkpoint..."

          # Send command to cat the checkpoint file (base64 encoded to handle binary)
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=["if [ -f /home/runner/work/benchmarks/benchmarks/results/checkpoint-x86.json ]; then cat /home/runner/work/benchmarks/benchmarks/results/checkpoint-x86.json | base64; else echo NO_CHECKPOINT; fi"]' \
            --output text --query 'Command.CommandId' 2>/dev/null || echo "")

          if [ -z "$COMMAND_ID" ]; then
            echo "Failed to send SSM command"
            echo "recovered=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "SSM Command ID: $COMMAND_ID"

          # Wait for command to complete (max 30 seconds)
          for i in {1..6}; do
            sleep 5
            STATUS=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "$INSTANCE_ID" \
              --query 'Status' --output text 2>/dev/null || echo "Pending")
            echo "Command status: $STATUS"
            if [ "$STATUS" == "Success" ] || [ "$STATUS" == "Failed" ]; then
              break
            fi
          done

          if [ "$STATUS" != "Success" ]; then
            echo "SSM command did not succeed (status: $STATUS)"
            echo "recovered=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Get command output
          OUTPUT=$(aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id "$INSTANCE_ID" \
            --query 'StandardOutputContent' --output text 2>/dev/null || echo "")

          if [ -z "$OUTPUT" ] || [ "$OUTPUT" == "NO_CHECKPOINT" ]; then
            echo "No checkpoint found on instance"
            echo "recovered=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Decode and save checkpoint
          mkdir -p ../recovered-checkpoint
          echo "$OUTPUT" | base64 -d > ../recovered-checkpoint/checkpoint-x86.json

          if [ -s ../recovered-checkpoint/checkpoint-x86.json ]; then
            echo "Checkpoint recovered successfully!"
            echo "recovered=true" >> $GITHUB_OUTPUT
            # Show checkpoint info
            echo "Checkpoint contents:"
            head -20 ../recovered-checkpoint/checkpoint-x86.json
          else
            echo "Failed to decode checkpoint"
            echo "recovered=false" >> $GITHUB_OUTPUT
          fi

      - name: Upload Recovered Checkpoint
        if: steps.recover.outputs.recovered == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: recovered-checkpoint-x86
          path: recovered-checkpoint/
          retention-days: 1

      - name: Cleanup Failed Spot Instance
        working-directory: terraform
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          TF_VAR_gh_pat_runner_token: ${{ secrets.GH_PAT_RUNNER_TOKEN }}
          TF_VAR_benchmark_mode: ${{ needs.launch-x86.outputs.benchmark_mode }}
          TF_VAR_launch_x86_only: "true"
        run: |
          echo "Cleaning up failed x86 spot instance..."
          terraform destroy -auto-approve || true

      - name: Launch x86 On-Demand
        id: launch
        working-directory: terraform
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          TF_VAR_gh_pat_runner_token: ${{ secrets.GH_PAT_RUNNER_TOKEN }}
          TF_VAR_benchmark_mode: ${{ needs.launch-x86.outputs.benchmark_mode }}
          TF_VAR_use_on_demand: "true"
          TF_VAR_launch_x86_only: "true"
        run: |
          echo "Launching x86 on-demand for retry (mode: $TF_VAR_benchmark_mode)..."
          set +e
          terraform apply -auto-approve
          EXIT_CODE=$?
          set -e
          if [ $EXIT_CODE -eq 0 ]; then
            echo "success=true" >> $GITHUB_OUTPUT
            echo "x86 on-demand launched successfully for retry"
          else
            echo "success=false" >> $GITHUB_OUTPUT
            echo "x86 on-demand failed with exit code $EXIT_CODE"
          fi

      - name: Set Retry Results
        id: result
        env:
          ORIGINAL_PROVISIONAL: ${{ needs.launch-x86.outputs.is_provisional }}
          ORIGINAL_MODE: ${{ needs.launch-x86.outputs.benchmark_mode }}
        run: |
          if [[ "${{ steps.launch.outputs.success }}" == "true" ]]; then
            echo "launched=true" >> $GITHUB_OUTPUT
            echo "is_provisional=$ORIGINAL_PROVISIONAL" >> $GITHUB_OUTPUT
            if [[ "$ORIGINAL_MODE" == "metal" ]]; then
              echo "instance_type=c5.metal-ondemand" >> $GITHUB_OUTPUT
              echo "runner_label=metal-x86" >> $GITHUB_OUTPUT
            else
              echo "instance_type=c5.2xlarge-ondemand" >> $GITHUB_OUTPUT
              echo "runner_label=provisional-x86" >> $GITHUB_OUTPUT
            fi
          else
            echo "launched=false" >> $GITHUB_OUTPUT
            echo "::error::x86 on-demand retry launch failed"
          fi

      - name: Wait for x86 Runner
        if: steps.result.outputs.launched == 'true'
        env:
          ORIGINAL_PROVISIONAL: ${{ needs.launch-x86.outputs.is_provisional }}
        run: |
          if [[ "$ORIGINAL_PROVISIONAL" == "true" ]]; then
            echo "Waiting for x86 provisional on-demand runner (60s)..."
            sleep 60
          else
            echo "Waiting for x86 metal on-demand runner (120s)..."
            sleep 120
          fi

  # Retry benchmark on ARM64 on-demand - continues from checkpoint
  retry-benchmark-arm64:
    name: Retry Benchmark (ARM64)
    needs: [launch-arm64, retry-arm64, benchmark-arm64]
    if: |
      always() &&
      needs.retry-arm64.outputs.launched == 'true'
    runs-on: [self-hosted, "${{ needs.retry-arm64.outputs.runner_label }}"]
    timeout-minutes: 90

    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Download Previous Checkpoint
        id: download_original
        uses: actions/download-artifact@v4
        with:
          name: benchmark-results-arm64
          path: results/
        continue-on-error: true

      - name: Download Recovered Checkpoint
        if: steps.download_original.outcome == 'failure'
        uses: actions/download-artifact@v4
        with:
          name: recovered-checkpoint-arm64
          path: results/
        continue-on-error: true

      - name: Check Checkpoint Status
        run: |
          if [ -f results/checkpoint-arm64.json ]; then
            echo "Checkpoint found!"
            echo "Checkpoint info:"
            head -5 results/checkpoint-arm64.json
            COMPLETED=$(grep -o '"completed"' results/checkpoint-arm64.json | wc -l || echo "0")
            echo "Approximately $COMPLETED benchmarks already completed"
          else
            echo "No checkpoint found - will start fresh"
          fi

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: "1.25.5"

      - name: Build and Resume
        env:
          BENCHMARK_DURATION: ${{ github.event.inputs.duration || '30s' }}
          BENCHMARK_MODE: ${{ github.event.inputs.benchmark_mode || 'all' }}
          IS_PROVISIONAL: ${{ needs.retry-arm64.outputs.is_provisional }}
          INSTANCE_TYPE: ${{ needs.retry-arm64.outputs.instance_type }}
        run: |
          echo "RETRY: Resuming benchmark on ARM64 on-demand instance"
          go mod download
          go build -o bin/server ./cmd/server
          go build -o bin/bench ./cmd/bench

          if [[ "$IS_PROVISIONAL" == "true" ]]; then
            echo "Running PROVISIONAL benchmarks on $INSTANCE_TYPE (retry)"
          else
            echo "Running OFFICIAL metal benchmarks on $INSTANCE_TYPE (retry)"
          fi

          # Check if checkpoint exists and resume from it
          if [ -f results/checkpoint-arm64.json ]; then
            echo "Found checkpoint, resuming from previous progress..."
            ./bin/bench -mode "$BENCHMARK_MODE" -duration "$BENCHMARK_DURATION"  -resume
          else
            echo "No checkpoint found, starting fresh..."
            ./bin/bench -mode "$BENCHMARK_MODE" -duration "$BENCHMARK_DURATION" 
          fi

      - name: Upload Results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: benchmark-results-arm64-retry
          path: results/
          retention-days: 90
          if-no-files-found: ignore

  # Retry benchmark on x86 on-demand - continues from checkpoint
  retry-benchmark-x86:
    name: Retry Benchmark (x86)
    needs: [launch-x86, retry-x86, benchmark-x86]
    if: |
      always() &&
      needs.retry-x86.outputs.launched == 'true'
    runs-on: [self-hosted, "${{ needs.retry-x86.outputs.runner_label }}"]
    timeout-minutes: 90

    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Download Previous Checkpoint
        id: download_original
        uses: actions/download-artifact@v4
        with:
          name: benchmark-results-x86
          path: results/
        continue-on-error: true

      - name: Download Recovered Checkpoint
        if: steps.download_original.outcome == 'failure'
        uses: actions/download-artifact@v4
        with:
          name: recovered-checkpoint-x86
          path: results/
        continue-on-error: true

      - name: Check Checkpoint Status
        run: |
          if [ -f results/checkpoint-x86.json ]; then
            echo "Checkpoint found!"
            echo "Checkpoint info:"
            head -5 results/checkpoint-x86.json
            COMPLETED=$(grep -o '"completed"' results/checkpoint-x86.json | wc -l || echo "0")
            echo "Approximately $COMPLETED benchmarks already completed"
          else
            echo "No checkpoint found - will start fresh"
          fi

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: "1.25.5"

      - name: Build and Resume
        env:
          BENCHMARK_DURATION: ${{ github.event.inputs.duration || '30s' }}
          BENCHMARK_MODE: ${{ github.event.inputs.benchmark_mode || 'all' }}
          IS_PROVISIONAL: ${{ needs.retry-x86.outputs.is_provisional }}
          INSTANCE_TYPE: ${{ needs.retry-x86.outputs.instance_type }}
        run: |
          echo "RETRY: Resuming benchmark on x86 on-demand instance"
          go mod download
          go build -o bin/server ./cmd/server
          go build -o bin/bench ./cmd/bench

          if [[ "$IS_PROVISIONAL" == "true" ]]; then
            echo "Running PROVISIONAL benchmarks on $INSTANCE_TYPE (retry)"
          else
            echo "Running OFFICIAL metal benchmarks on $INSTANCE_TYPE (retry)"
          fi

          # Check if checkpoint exists and resume from it
          if [ -f results/checkpoint-x86.json ]; then
            echo "Found checkpoint, resuming from previous progress..."
            ./bin/bench -mode "$BENCHMARK_MODE" -duration "$BENCHMARK_DURATION"  -resume
          else
            echo "No checkpoint found, starting fresh..."
            ./bin/bench -mode "$BENCHMARK_MODE" -duration "$BENCHMARK_DURATION" 
          fi

      - name: Upload Results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: benchmark-results-x86-retry
          path: results/
          retention-days: 90
          if-no-files-found: ignore

  report:
    name: Generate Report
    needs: [authorize, launch-arm64, launch-x86, benchmark-arm64, benchmark-x86, retry-arm64, retry-x86, retry-benchmark-arm64, retry-benchmark-x86]
    runs-on: ubuntu-latest
    if: |
      always() &&
      needs.authorize.outputs.authorized == 'true' &&
      (needs.benchmark-arm64.result == 'success' || needs.benchmark-x86.result == 'success' ||
       needs.retry-benchmark-arm64.result == 'success' || needs.retry-benchmark-x86.result == 'success')
    permissions:
      contents: write

    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Download ARM64 Results
        uses: actions/download-artifact@v4
        with:
          name: benchmark-results-arm64
          path: downloaded/arm64
        continue-on-error: true

      - name: Download ARM64 Retry Results
        uses: actions/download-artifact@v4
        with:
          name: benchmark-results-arm64-retry
          path: downloaded/arm64-retry
        continue-on-error: true

      - name: Download x86 Results
        uses: actions/download-artifact@v4
        with:
          name: benchmark-results-x86
          path: downloaded/x86
        continue-on-error: true

      - name: Download x86 Retry Results
        uses: actions/download-artifact@v4
        with:
          name: benchmark-results-x86-retry
          path: downloaded/x86-retry
        continue-on-error: true

      - name: Setup Python
        uses: actions/setup-python@v6
        with:
          python-version: "3.11"

      - name: Generate Charts and Organize Results
        env:
          ARM64_PROVISIONAL: ${{ needs.launch-arm64.outputs.is_provisional }}
          ARM64_INSTANCE: ${{ needs.launch-arm64.outputs.instance_type }}
          ARM64_LAUNCHED: ${{ needs.launch-arm64.outputs.launched }}
          ARM64_RETRY_PROVISIONAL: ${{ needs.retry-arm64.outputs.is_provisional }}
          ARM64_RETRY_INSTANCE: ${{ needs.retry-arm64.outputs.instance_type }}
          ARM64_ORIGINAL_SUCCESS: ${{ needs.benchmark-arm64.result == 'success' }}
          ARM64_RETRY_SUCCESS: ${{ needs.retry-benchmark-arm64.result == 'success' }}
          X86_PROVISIONAL: ${{ needs.launch-x86.outputs.is_provisional }}
          X86_INSTANCE: ${{ needs.launch-x86.outputs.instance_type }}
          X86_LAUNCHED: ${{ needs.launch-x86.outputs.launched }}
          X86_RETRY_PROVISIONAL: ${{ needs.retry-x86.outputs.is_provisional }}
          X86_RETRY_INSTANCE: ${{ needs.retry-x86.outputs.instance_type }}
          X86_ORIGINAL_SUCCESS: ${{ needs.benchmark-x86.result == 'success' }}
          X86_RETRY_SUCCESS: ${{ needs.retry-benchmark-x86.result == 'success' }}
          IS_RELEASE: ${{ github.event_name == 'release' }}
          VERSION: ${{ github.event.release.tag_name || 'latest' }}
        run: |
          pip install matplotlib numpy

          # Track which architectures have results
          ARM64_HAS_RESULTS="false"
          X86_HAS_RESULTS="false"

          # Determine which ARM64 results to use and final status
          if [[ "$ARM64_RETRY_SUCCESS" == "true" ]]; then
            ARM64_SOURCE="downloaded/arm64-retry"
            ARM64_FINAL_PROVISIONAL="$ARM64_RETRY_PROVISIONAL"
            ARM64_FINAL_INSTANCE="$ARM64_RETRY_INSTANCE"
            ARM64_HAS_RESULTS="true"
            echo "Using ARM64 retry results"
          elif [[ "$ARM64_ORIGINAL_SUCCESS" == "true" ]]; then
            ARM64_SOURCE="downloaded/arm64"
            ARM64_FINAL_PROVISIONAL="$ARM64_PROVISIONAL"
            ARM64_FINAL_INSTANCE="$ARM64_INSTANCE"
            ARM64_HAS_RESULTS="true"
            echo "Using ARM64 original results"
          else
            ARM64_SOURCE=""
            ARM64_FINAL_PROVISIONAL=""
            ARM64_FINAL_INSTANCE="none"
            echo "No ARM64 results available"
          fi

          # Determine which x86 results to use and final status
          if [[ "$X86_RETRY_SUCCESS" == "true" ]]; then
            X86_SOURCE="downloaded/x86-retry"
            X86_FINAL_PROVISIONAL="$X86_RETRY_PROVISIONAL"
            X86_FINAL_INSTANCE="$X86_RETRY_INSTANCE"
            X86_HAS_RESULTS="true"
            echo "Using x86 retry results"
          elif [[ "$X86_ORIGINAL_SUCCESS" == "true" ]]; then
            X86_SOURCE="downloaded/x86"
            X86_FINAL_PROVISIONAL="$X86_PROVISIONAL"
            X86_FINAL_INSTANCE="$X86_INSTANCE"
            X86_HAS_RESULTS="true"
            echo "Using x86 original results"
          else
            X86_SOURCE=""
            X86_FINAL_PROVISIONAL=""
            X86_FINAL_INSTANCE="none"
            echo "No x86 results available"
          fi

          # Determine folder names based on provisional status
          if [[ "$ARM64_FINAL_PROVISIONAL" == "true" ]]; then
            ARM64_FOLDER="arm64-provisional"
          else
            ARM64_FOLDER="arm64"
          fi

          if [[ "$X86_FINAL_PROVISIONAL" == "true" ]]; then
            X86_FOLDER="x86-provisional"
          else
            X86_FOLDER="x86"
          fi

          echo "ARM64: has_results=$ARM64_HAS_RESULTS folder=$ARM64_FOLDER instance=$ARM64_FINAL_INSTANCE"
          echo "x86: has_results=$X86_HAS_RESULTS folder=$X86_FOLDER instance=$X86_FINAL_INSTANCE"

          # Process ARM64 results (only if we have them)
          if [[ "$ARM64_HAS_RESULTS" == "true" && -n "$ARM64_SOURCE" ]]; then
            ARM64_JSON=$(find "$ARM64_SOURCE" -name "benchmark-*.json" 2>/dev/null | head -1)
            if [ -n "$ARM64_JSON" ]; then
              mkdir -p "results/latest/$ARM64_FOLDER"
              ARM64_DIR=$(dirname "$ARM64_JSON")
              echo "Processing ARM64 results from: $ARM64_DIR"
              python scripts/generate_charts.py "$ARM64_DIR" "results/latest/$ARM64_FOLDER"
              cp "$ARM64_DIR"/*.json "results/latest/$ARM64_FOLDER/" 2>/dev/null || true
            else
              echo "WARNING: ARM64 marked as success but no JSON found in $ARM64_SOURCE"
              ARM64_HAS_RESULTS="false"
            fi
          fi

          # Process x86 results (only if we have them)
          if [[ "$X86_HAS_RESULTS" == "true" && -n "$X86_SOURCE" ]]; then
            X86_JSON=$(find "$X86_SOURCE" -name "benchmark-*.json" 2>/dev/null | head -1)
            if [ -n "$X86_JSON" ]; then
              mkdir -p "results/latest/$X86_FOLDER"
              X86_DIR=$(dirname "$X86_JSON")
              echo "Processing x86 results from: $X86_DIR"
              python scripts/generate_charts.py "$X86_DIR" "results/latest/$X86_FOLDER"
              cp "$X86_DIR"/*.json "results/latest/$X86_FOLDER/" 2>/dev/null || true
            else
              echo "WARNING: x86 marked as success but no JSON found in $X86_SOURCE"
              X86_HAS_RESULTS="false"
            fi
          fi

          # Create metadata (only include architectures that have results)
          cat > "results/latest/BENCHMARK_INFO.json" << EOFMETA
          {
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "triggered_by": "${{ github.actor }}",
            "event": "${{ github.event_name }}",
            "version": "$VERSION",
            "arm64": {
              "available": $ARM64_HAS_RESULTS,
              "status": "$([ "$ARM64_HAS_RESULTS" == "true" ] && ([ "$ARM64_FINAL_PROVISIONAL" == "true" ] && echo "provisional" || echo "official") || echo "failed")",
              "instance_type": "$ARM64_FINAL_INSTANCE",
              "folder": "$([ "$ARM64_HAS_RESULTS" == "true" ] && echo "$ARM64_FOLDER" || echo "")"
            },
            "x86": {
              "available": $X86_HAS_RESULTS,
              "status": "$([ "$X86_HAS_RESULTS" == "true" ] && ([ "$X86_FINAL_PROVISIONAL" == "true" ] && echo "provisional" || echo "official") || echo "failed")",
              "instance_type": "$X86_FINAL_INSTANCE",
              "folder": "$([ "$X86_HAS_RESULTS" == "true" ] && echo "$X86_FOLDER" || echo "")"
            }
          }
          EOFMETA

          echo "Created BENCHMARK_INFO.json:"
          cat "results/latest/BENCHMARK_INFO.json"

          # For releases, also create version folder
          if [[ "$IS_RELEASE" == "true" && -n "$VERSION" ]]; then
            mkdir -p "results/$VERSION"
            if [[ "$ARM64_HAS_RESULTS" == "true" ]]; then
              cp -r "results/latest/$ARM64_FOLDER" "results/$VERSION/" 2>/dev/null || true
            fi
            if [[ "$X86_HAS_RESULTS" == "true" ]]; then
              cp -r "results/latest/$X86_FOLDER" "results/$VERSION/" 2>/dev/null || true
            fi
            cp "results/latest/BENCHMARK_INFO.json" "results/$VERSION/" 2>/dev/null || true
          fi

          # Update provisional status tracking file
          PROV_FILE="results/PROVISIONAL_STATUS.json"
          if [ ! -f "$PROV_FILE" ]; then
            echo "{}" > "$PROV_FILE"
          fi

          # Update status using Python for proper JSON handling
          python3 << PYEOF
          import json
          import os

          prov_file = "$PROV_FILE"
          version = "$VERSION"
          arm64_has = "$ARM64_HAS_RESULTS" == "true"
          x86_has = "$X86_HAS_RESULTS" == "true"
          arm64_prov = "$ARM64_FINAL_PROVISIONAL" == "true"
          x86_prov = "$X86_FINAL_PROVISIONAL" == "true"
          arm64_inst = "$ARM64_FINAL_INSTANCE"
          x86_inst = "$X86_FINAL_INSTANCE"

          try:
              with open(prov_file, 'r') as f:
                  data = json.load(f)
          except:
              data = {}

          data[version] = {
              "arm64": {
                  "available": arm64_has,
                  "provisional": arm64_prov if arm64_has else None,
                  "instance_type": arm64_inst if arm64_has else None
              },
              "x86": {
                  "available": x86_has,
                  "provisional": x86_prov if x86_has else None,
                  "instance_type": x86_inst if x86_has else None
              }
          }

          with open(prov_file, 'w') as f:
              json.dump(data, f, indent=2)

          print(f"Updated {prov_file} for version {version}")
          PYEOF

          # Export for later steps
          echo "ARM64_FOLDER=$ARM64_FOLDER" >> $GITHUB_ENV
          echo "X86_FOLDER=$X86_FOLDER" >> $GITHUB_ENV
          echo "ARM64_HAS_RESULTS=$ARM64_HAS_RESULTS" >> $GITHUB_ENV
          echo "X86_HAS_RESULTS=$X86_HAS_RESULTS" >> $GITHUB_ENV
          echo "ARM64_FINAL_PROVISIONAL=$ARM64_FINAL_PROVISIONAL" >> $GITHUB_ENV
          echo "ARM64_FINAL_INSTANCE=$ARM64_FINAL_INSTANCE" >> $GITHUB_ENV
          echo "X86_FINAL_PROVISIONAL=$X86_FINAL_PROVISIONAL" >> $GITHUB_ENV
          echo "X86_FINAL_INSTANCE=$X86_FINAL_INSTANCE" >> $GITHUB_ENV

      - name: Upload Charts
        uses: actions/upload-artifact@v4
        with:
          name: benchmark-charts
          path: results/latest/
          retention-days: 365

      - name: Commit Results
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_RUNNER_TOKEN }}
          VERSION: ${{ github.event.release.tag_name || '' }}
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Always checkout main before committing (handles both releases and workflow_dispatch)
          echo "Checking out main branch..."
          git fetch origin main
          git checkout main
          git pull origin main

          # Add all results
          git add -f results/latest/
          git add -f results/PROVISIONAL_STATUS.json

          # For releases, also add version folder
          if [ -n "$VERSION" ] && [ -d "results/$VERSION" ]; then
            git add -f "results/$VERSION/"
          fi

          # Show what will be committed
          echo "Changes to be committed:"
          git status --short

          git commit -m "chore: update benchmark results [skip ci]" || echo "No changes to commit"

          # Use PAT for push to bypass branch protection rules
          git remote set-url origin "https://x-access-token:${GH_TOKEN}@github.com/${{ github.repository }}.git"
          git push origin main || {
            echo "::error::Push to main failed"
            exit 1
          }

      - name: Create Summary
        run: |
          echo "# Benchmark Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # ARM64 status
          if [[ "$ARM64_HAS_RESULTS" == "true" ]]; then
            if [[ "$ARM64_FINAL_PROVISIONAL" == "true" ]]; then
              echo "## ARM64 Results (PROVISIONAL)" >> $GITHUB_STEP_SUMMARY
              echo "> Run on **$ARM64_FINAL_INSTANCE** - not official metal results" >> $GITHUB_STEP_SUMMARY
            else
              echo "## ARM64 Results (Official)" >> $GITHUB_STEP_SUMMARY
              echo "> Run on **$ARM64_FINAL_INSTANCE**" >> $GITHUB_STEP_SUMMARY
            fi
            echo "" >> $GITHUB_STEP_SUMMARY
            if [ -f "results/latest/${{ env.ARM64_FOLDER }}/summary_arm64.md" ]; then
              cat "results/latest/${{ env.ARM64_FOLDER }}/summary_arm64.md" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "## ARM64 Results" >> $GITHUB_STEP_SUMMARY
            echo "> **FAILED** - No results available (launch or benchmark failed)" >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY

          # x86 status
          if [[ "$X86_HAS_RESULTS" == "true" ]]; then
            if [[ "$X86_FINAL_PROVISIONAL" == "true" ]]; then
              echo "## x86 Results (PROVISIONAL)" >> $GITHUB_STEP_SUMMARY
              echo "> Run on **$X86_FINAL_INSTANCE** - not official metal results" >> $GITHUB_STEP_SUMMARY
            else
              echo "## x86 Results (Official)" >> $GITHUB_STEP_SUMMARY
              echo "> Run on **$X86_FINAL_INSTANCE**" >> $GITHUB_STEP_SUMMARY
            fi
            echo "" >> $GITHUB_STEP_SUMMARY
            if [ -f "results/latest/${{ env.X86_FOLDER }}/summary_x86.md" ]; then
              cat "results/latest/${{ env.X86_FOLDER }}/summary_x86.md" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "## x86 Results" >> $GITHUB_STEP_SUMMARY
            echo "> **FAILED** - No results available (launch or benchmark failed)" >> $GITHUB_STEP_SUMMARY
          fi

          # Notes
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY

          if [[ "$ARM64_HAS_RESULTS" != "true" || "$X86_HAS_RESULTS" != "true" ]]; then
            echo "**Warning**: Some architectures failed. Check the workflow logs for details." >> $GITHUB_STEP_SUMMARY
          fi

          if [[ "$ARM64_FINAL_PROVISIONAL" == "true" || "$X86_FINAL_PROVISIONAL" == "true" ]]; then
            echo "**Note**: Some results are provisional. Run the **Promote Provisional** workflow when metal quota is available." >> $GITHUB_STEP_SUMMARY
          fi

  cleanup-arm64:
    name: Cleanup ARM64 Infrastructure
    needs: [authorize, launch-arm64, benchmark-arm64, retry-arm64, retry-benchmark-arm64]
    runs-on: ubuntu-latest
    if: |
      always() &&
      needs.authorize.outputs.authorized == 'true' &&
      (needs.launch-arm64.outputs.launched == 'true' || needs.retry-arm64.outputs.launched == 'true')

    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.6.0"
          terraform_wrapper: false

      - name: Direct AWS Cleanup ARM64
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ env.AWS_REGION }}
        run: |
          echo "Terminating ARM64 instances by tag (direct AWS API)..."

          # Find and terminate all ARM64 benchmark instances by tag
          # Tag format: benchmark-server-arm64-* or benchmark-client-arm64-*
          INSTANCE_IDS=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=benchmark-*-arm64-*" \
                      "Name=instance-state-name,Values=pending,running,stopping,stopped" \
            --query 'Reservations[].Instances[].InstanceId' \
            --output text)

          if [ -n "$INSTANCE_IDS" ] && [ "$INSTANCE_IDS" != "None" ]; then
            echo "Found ARM64 instances: $INSTANCE_IDS"
            aws ec2 terminate-instances --instance-ids $INSTANCE_IDS || true
            echo "Termination request sent"
          else
            echo "No ARM64 instances found to terminate"
          fi

          # Also cancel any spot requests
          SPOT_IDS=$(aws ec2 describe-spot-instance-requests \
            --filters "Name=tag:Name,Values=benchmark-*-arm64-*" \
                      "Name=state,Values=open,active" \
            --query 'SpotInstanceRequests[].SpotInstanceRequestId' \
            --output text 2>/dev/null || echo "")

          if [ -n "$SPOT_IDS" ] && [ "$SPOT_IDS" != "None" ]; then
            echo "Found ARM64 spot requests: $SPOT_IDS"
            aws ec2 cancel-spot-instance-requests --spot-instance-request-ids $SPOT_IDS || true
          fi

      - name: Terraform Destroy ARM64 (backup)
        continue-on-error: true
        working-directory: terraform
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          TF_VAR_gh_pat_runner_token: ${{ secrets.GH_PAT_RUNNER_TOKEN }}
          TF_VAR_launch_arm64_only: "true"
        run: |
          terraform init
          # Try destroying via Terraform as backup (may have no state)
          terraform destroy -auto-approve || true

      - name: Cleanup Offline Runners
        if: always()
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_RUNNER_TOKEN }}
        run: |
          # Remove any offline self-hosted runners with arm64 in the name
          RUNNERS=$(gh api repos/${{ github.repository }}/actions/runners --jq '.runners[] | select(.status == "offline") | select(.name | contains("arm64")) | "\(.id) \(.name)"')
          if [ -n "$RUNNERS" ]; then
            echo "$RUNNERS" | while read id name; do
              echo "Removing offline runner: $name"
              gh api -X DELETE repos/${{ github.repository }}/actions/runners/$id || true
            done
          fi

  cleanup-x86:
    name: Cleanup x86 Infrastructure
    needs: [authorize, launch-x86, benchmark-x86, retry-x86, retry-benchmark-x86]
    runs-on: ubuntu-latest
    if: |
      always() &&
      needs.authorize.outputs.authorized == 'true' &&
      (needs.launch-x86.outputs.launched == 'true' || needs.retry-x86.outputs.launched == 'true')

    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.6.0"
          terraform_wrapper: false

      - name: Direct AWS Cleanup x86
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ env.AWS_REGION }}
        run: |
          echo "Terminating x86 instances by tag (direct AWS API)..."

          # Find and terminate all x86 benchmark instances by tag
          # Tag format: benchmark-server-x86-* or benchmark-client-x86-*
          INSTANCE_IDS=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=benchmark-*-x86-*" \
                      "Name=instance-state-name,Values=pending,running,stopping,stopped" \
            --query 'Reservations[].Instances[].InstanceId' \
            --output text)

          if [ -n "$INSTANCE_IDS" ] && [ "$INSTANCE_IDS" != "None" ]; then
            echo "Found x86 instances: $INSTANCE_IDS"
            aws ec2 terminate-instances --instance-ids $INSTANCE_IDS || true
            echo "Termination request sent"
          else
            echo "No x86 instances found to terminate"
          fi

          # Also cancel any spot requests
          SPOT_IDS=$(aws ec2 describe-spot-instance-requests \
            --filters "Name=tag:Name,Values=benchmark-*-x86-*" \
                      "Name=state,Values=open,active" \
            --query 'SpotInstanceRequests[].SpotInstanceRequestId' \
            --output text 2>/dev/null || echo "")

          if [ -n "$SPOT_IDS" ] && [ "$SPOT_IDS" != "None" ]; then
            echo "Found x86 spot requests: $SPOT_IDS"
            aws ec2 cancel-spot-instance-requests --spot-instance-request-ids $SPOT_IDS || true
          fi

      - name: Terraform Destroy x86 (backup)
        continue-on-error: true
        working-directory: terraform
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          TF_VAR_gh_pat_runner_token: ${{ secrets.GH_PAT_RUNNER_TOKEN }}
          TF_VAR_launch_x86_only: "true"
        run: |
          terraform init
          # Try destroying via Terraform as backup (may have no state)
          terraform destroy -auto-approve || true

      - name: Cleanup Offline Runners
        if: always()
        env:
          GH_TOKEN: ${{ secrets.GH_PAT_RUNNER_TOKEN }}
        run: |
          # Remove any offline self-hosted runners with x86 in the name
          RUNNERS=$(gh api repos/${{ github.repository }}/actions/runners --jq '.runners[] | select(.status == "offline") | select(.name | contains("x86")) | "\(.id) \(.name)"')
          if [ -n "$RUNNERS" ]; then
            echo "$RUNNERS" | while read id name; do
              echo "Removing offline runner: $name"
              gh api -X DELETE repos/${{ github.repository }}/actions/runners/$id || true
            done
          fi
