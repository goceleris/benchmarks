name: Benchmark (Metal)

# Metal mode: Official benchmarks on bare-metal instances
# Falls back to provisional (best available) if metal quota unavailable
# Uses c5.metal/c6g.metal (official) or c5.2xlarge/c6g.2xlarge (provisional)
#
# Security: Only authorized users can trigger (to protect AWS resources)
# - Releases: Only users with release permissions can publish
# - workflow_dispatch: Requires write/maintain/admin permissions

on:
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      duration:
        description: "Benchmark duration (e.g., 30s, 60s)"
        required: false
        default: "30s"
      benchmark_mode:
        description: "Benchmark servers to test"
        required: false
        default: "all"
        type: choice
        options:
          - baseline
          - theoretical
          - all

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

env:
  TF_VAR_repository_url: ${{ github.server_url }}/${{ github.repository }}
  TF_VAR_benchmark_mode: metal

jobs:
  authorize:
    name: Authorize Caller
    runs-on: ubuntu-latest
    outputs:
      authorized: ${{ steps.check.outputs.authorized }}
    steps:
      - name: Check Permissions
        id: check
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          if [[ "${{ github.event_name }}" == "release" ]]; then
            # Releases are inherently authorized (only release creators can publish)
            echo "authorized=true" >> $GITHUB_OUTPUT
            echo "Release event - authorized (release creator: ${{ github.actor }})"
          elif [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            # Manual triggers require write/maintain/admin permissions
            PERMISSION=$(gh api repos/${{ github.repository }}/collaborators/${{ github.actor }}/permission --jq '.permission')
            echo "User: ${{ github.actor }}"
            echo "Permission level: $PERMISSION"
            if [[ "$PERMISSION" == "admin" || "$PERMISSION" == "maintain" || "$PERMISSION" == "write" ]]; then
              echo "authorized=true" >> $GITHUB_OUTPUT
              echo "User ${{ github.actor }} authorized with permission: $PERMISSION"
            else
              echo "authorized=false" >> $GITHUB_OUTPUT
              echo "::error::Unauthorized: Only maintainers and owners can trigger metal benchmarks"
              exit 1
            fi
          else
            echo "authorized=false" >> $GITHUB_OUTPUT
            echo "::error::Unknown event type: ${{ github.event_name }}"
            exit 1
          fi

  launch:
    name: Launch Infrastructure
    runs-on: ubuntu-latest
    needs: authorize
    if: needs.authorize.outputs.authorized == 'true'
    outputs:
      arm64_launched: ${{ steps.result.outputs.arm64_launched }}
      x86_launched: ${{ steps.result.outputs.x86_launched }}
      instance_mode: ${{ steps.result.outputs.instance_mode }}
      is_provisional: ${{ steps.result.outputs.is_provisional }}
      runner_label_arm64: ${{ steps.result.outputs.runner_label_arm64 }}
      runner_label_x86: ${{ steps.result.outputs.runner_label_x86 }}

    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.6.0"

      - name: Terraform Init
        working-directory: terraform
        run: terraform init

      # Attempt 1: Metal Spot
      - name: Try Metal Spot
        id: metal_spot
        continue-on-error: true
        working-directory: terraform
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          TF_VAR_gh_pat_runner_token: ${{ secrets.GH_PAT_RUNNER_TOKEN }}
        run: |
          echo "Attempting metal spot instances..."
          if terraform apply -auto-approve; then
            echo "success=true" >> $GITHUB_OUTPUT
          else
            echo "success=false" >> $GITHUB_OUTPUT
          fi

      # Attempt 2: Metal On-Demand
      - name: Cleanup for Metal On-Demand
        if: steps.metal_spot.outputs.success != 'true'
        working-directory: terraform
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          TF_VAR_gh_pat_runner_token: ${{ secrets.GH_PAT_RUNNER_TOKEN }}
        run: terraform destroy -auto-approve || true

      - name: Try Metal On-Demand
        id: metal_ondemand
        if: steps.metal_spot.outputs.success != 'true'
        continue-on-error: true
        working-directory: terraform
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          TF_VAR_gh_pat_runner_token: ${{ secrets.GH_PAT_RUNNER_TOKEN }}
          TF_VAR_use_on_demand: "true"
        run: |
          echo "Attempting metal on-demand instances..."
          if terraform apply -auto-approve; then
            echo "success=true" >> $GITHUB_OUTPUT
          else
            echo "success=false" >> $GITHUB_OUTPUT
          fi

      # Attempt 3: Provisional Spot
      - name: Cleanup for Provisional Spot
        if: steps.metal_spot.outputs.success != 'true' && steps.metal_ondemand.outputs.success != 'true'
        working-directory: terraform
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          TF_VAR_gh_pat_runner_token: ${{ secrets.GH_PAT_RUNNER_TOKEN }}
          TF_VAR_use_on_demand: "true"
        run: terraform destroy -auto-approve || true

      - name: Try Provisional Spot
        id: provisional_spot
        if: steps.metal_spot.outputs.success != 'true' && steps.metal_ondemand.outputs.success != 'true'
        continue-on-error: true
        working-directory: terraform
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          TF_VAR_gh_pat_runner_token: ${{ secrets.GH_PAT_RUNNER_TOKEN }}
          TF_VAR_use_provisional: "true"
        run: |
          echo "Attempting provisional spot instances (c6g.2xlarge/c5.2xlarge)..."
          if terraform apply -auto-approve; then
            echo "success=true" >> $GITHUB_OUTPUT
          else
            echo "success=false" >> $GITHUB_OUTPUT
          fi

      # Attempt 4: Provisional On-Demand
      - name: Cleanup for Provisional On-Demand
        if: steps.metal_spot.outputs.success != 'true' && steps.metal_ondemand.outputs.success != 'true' && steps.provisional_spot.outputs.success != 'true'
        working-directory: terraform
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          TF_VAR_gh_pat_runner_token: ${{ secrets.GH_PAT_RUNNER_TOKEN }}
          TF_VAR_use_provisional: "true"
        run: terraform destroy -auto-approve || true

      - name: Try Provisional On-Demand
        id: provisional_ondemand
        if: steps.metal_spot.outputs.success != 'true' && steps.metal_ondemand.outputs.success != 'true' && steps.provisional_spot.outputs.success != 'true'
        continue-on-error: true
        working-directory: terraform
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          TF_VAR_gh_pat_runner_token: ${{ secrets.GH_PAT_RUNNER_TOKEN }}
          TF_VAR_use_provisional: "true"
          TF_VAR_use_on_demand: "true"
        run: |
          echo "Attempting provisional on-demand instances..."
          if terraform apply -auto-approve; then
            echo "success=true" >> $GITHUB_OUTPUT
          else
            echo "success=false" >> $GITHUB_OUTPUT
          fi

      - name: Set Launch Results
        id: result
        run: |
          if [[ "${{ steps.metal_spot.outputs.success }}" == "true" ]]; then
            echo "arm64_launched=true" >> $GITHUB_OUTPUT
            echo "x86_launched=true" >> $GITHUB_OUTPUT
            echo "instance_mode=metal-spot" >> $GITHUB_OUTPUT
            echo "is_provisional=false" >> $GITHUB_OUTPUT
            echo "runner_label_arm64=metal-arm64" >> $GITHUB_OUTPUT
            echo "runner_label_x86=metal-x86" >> $GITHUB_OUTPUT
          elif [[ "${{ steps.metal_ondemand.outputs.success }}" == "true" ]]; then
            echo "arm64_launched=true" >> $GITHUB_OUTPUT
            echo "x86_launched=true" >> $GITHUB_OUTPUT
            echo "instance_mode=metal-ondemand" >> $GITHUB_OUTPUT
            echo "is_provisional=false" >> $GITHUB_OUTPUT
            echo "runner_label_arm64=metal-arm64" >> $GITHUB_OUTPUT
            echo "runner_label_x86=metal-x86" >> $GITHUB_OUTPUT
          elif [[ "${{ steps.provisional_spot.outputs.success }}" == "true" ]]; then
            echo "arm64_launched=true" >> $GITHUB_OUTPUT
            echo "x86_launched=true" >> $GITHUB_OUTPUT
            echo "instance_mode=provisional-spot" >> $GITHUB_OUTPUT
            echo "is_provisional=true" >> $GITHUB_OUTPUT
            echo "runner_label_arm64=provisional-arm64" >> $GITHUB_OUTPUT
            echo "runner_label_x86=provisional-x86" >> $GITHUB_OUTPUT
          elif [[ "${{ steps.provisional_ondemand.outputs.success }}" == "true" ]]; then
            echo "arm64_launched=true" >> $GITHUB_OUTPUT
            echo "x86_launched=true" >> $GITHUB_OUTPUT
            echo "instance_mode=provisional-ondemand" >> $GITHUB_OUTPUT
            echo "is_provisional=true" >> $GITHUB_OUTPUT
            echo "runner_label_arm64=provisional-arm64" >> $GITHUB_OUTPUT
            echo "runner_label_x86=provisional-x86" >> $GITHUB_OUTPUT
          else
            echo "arm64_launched=false" >> $GITHUB_OUTPUT
            echo "x86_launched=false" >> $GITHUB_OUTPUT
            echo "instance_mode=none" >> $GITHUB_OUTPUT
            echo "is_provisional=false" >> $GITHUB_OUTPUT
            echo "::error::All launch attempts failed"
            exit 1
          fi

      - name: Wait for Runners
        run: |
          if [[ "${{ steps.result.outputs.is_provisional }}" == "true" ]]; then
            echo "Waiting for provisional runners to register (60s)..."
            sleep 60
          else
            echo "Waiting for metal runners to register (120s)..."
            sleep 120
          fi

  benchmark-arm64:
    name: Benchmark (ARM64)
    needs: launch
    if: needs.launch.outputs.arm64_launched == 'true'
    runs-on: [self-hosted, "${{ needs.launch.outputs.runner_label_arm64 }}"]
    timeout-minutes: 60

    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: "1.25.5"

      - name: Build Server and Benchmark Tool
        run: |
          go mod download
          go build -o bin/server ./cmd/server
          go build -o bin/bench ./cmd/bench

      - name: Run Benchmarks
        env:
          BENCHMARK_DURATION: ${{ github.event.inputs.duration || '30s' }}
          BENCHMARK_MODE: ${{ github.event.inputs.benchmark_mode || 'all' }}
          IS_PROVISIONAL: ${{ needs.launch.outputs.is_provisional }}
        run: |
          if [[ "$IS_PROVISIONAL" == "true" ]]; then
            echo "Running PROVISIONAL benchmarks (c6g.2xlarge)"
          else
            echo "Running OFFICIAL metal benchmarks (c6g.metal)"
          fi
          ./bin/bench -mode "$BENCHMARK_MODE" -duration "$BENCHMARK_DURATION" -connections 256 -workers 8

      - name: Upload Results
        uses: actions/upload-artifact@v4
        with:
          name: benchmark-results-arm64
          path: results/
          retention-days: 90

  benchmark-x86:
    name: Benchmark (x86)
    needs: launch
    if: needs.launch.outputs.x86_launched == 'true'
    runs-on: [self-hosted, "${{ needs.launch.outputs.runner_label_x86 }}"]
    timeout-minutes: 60

    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: "1.25.5"

      - name: Build Server and Benchmark Tool
        run: |
          go mod download
          go build -o bin/server ./cmd/server
          go build -o bin/bench ./cmd/bench

      - name: Run Benchmarks
        env:
          BENCHMARK_DURATION: ${{ github.event.inputs.duration || '30s' }}
          BENCHMARK_MODE: ${{ github.event.inputs.benchmark_mode || 'all' }}
          IS_PROVISIONAL: ${{ needs.launch.outputs.is_provisional }}
        run: |
          if [[ "$IS_PROVISIONAL" == "true" ]]; then
            echo "Running PROVISIONAL benchmarks (c5.2xlarge)"
          else
            echo "Running OFFICIAL metal benchmarks (c5.metal)"
          fi
          ./bin/bench -mode "$BENCHMARK_MODE" -duration "$BENCHMARK_DURATION" -connections 256 -workers 8

      - name: Upload Results
        uses: actions/upload-artifact@v4
        with:
          name: benchmark-results-x86
          path: results/
          retention-days: 90

  report:
    name: Generate Report
    needs: [authorize, launch, benchmark-arm64, benchmark-x86]
    runs-on: ubuntu-latest
    if: always() && needs.authorize.outputs.authorized == 'true' && (needs.benchmark-arm64.result == 'success' || needs.benchmark-x86.result == 'success')
    permissions:
      contents: write

    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Download ARM64 Results
        uses: actions/download-artifact@v4
        with:
          name: benchmark-results-arm64
          path: downloaded/arm64
        continue-on-error: true

      - name: Download x86 Results
        uses: actions/download-artifact@v4
        with:
          name: benchmark-results-x86
          path: downloaded/x86
        continue-on-error: true

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Generate Charts and Organize Results
        env:
          IS_PROVISIONAL: ${{ needs.launch.outputs.is_provisional }}
          INSTANCE_MODE: ${{ needs.launch.outputs.instance_mode }}
        run: |
          pip install matplotlib numpy

          # Determine output directory based on provisional status
          if [[ "$IS_PROVISIONAL" == "true" ]]; then
            OUTPUT_DIR="results/provisional"
            echo "Storing results as PROVISIONAL (will need promotion to official)"
          else
            OUTPUT_DIR="results/latest"
            echo "Storing results as OFFICIAL"
          fi

          mkdir -p "$OUTPUT_DIR/arm64" "$OUTPUT_DIR/x86"

          # Process ARM64 results
          if [ -d "downloaded/arm64" ]; then
            ARM64_JSON=$(find downloaded/arm64 -name "benchmark-*.json" 2>/dev/null | head -1)
            if [ -n "$ARM64_JSON" ]; then
              ARM64_DIR=$(dirname "$ARM64_JSON")
              echo "Found ARM64 results in: $ARM64_DIR"
              python scripts/generate_charts.py "$ARM64_DIR" "$OUTPUT_DIR/arm64"
              cp "$ARM64_DIR"/*.json "$OUTPUT_DIR/arm64/" 2>/dev/null || true
            fi
          fi

          # Process x86 results
          if [ -d "downloaded/x86" ]; then
            X86_JSON=$(find downloaded/x86 -name "benchmark-*.json" 2>/dev/null | head -1)
            if [ -n "$X86_JSON" ]; then
              X86_DIR=$(dirname "$X86_JSON")
              echo "Found x86 results in: $X86_DIR"
              python scripts/generate_charts.py "$X86_DIR" "$OUTPUT_DIR/x86"
              cp "$X86_DIR"/*.json "$OUTPUT_DIR/x86/" 2>/dev/null || true
            fi
          fi

          # Add metadata
          echo "Last updated: $(date -u)" > "$OUTPUT_DIR/TIMESTAMP"
          echo "Triggered by: ${{ github.actor }}" >> "$OUTPUT_DIR/TIMESTAMP"
          echo "Event: ${{ github.event_name }}" >> "$OUTPUT_DIR/TIMESTAMP"
          echo "Instance mode: $INSTANCE_MODE" >> "$OUTPUT_DIR/TIMESTAMP"
          echo "Provisional: $IS_PROVISIONAL" >> "$OUTPUT_DIR/TIMESTAMP"

          # Export for later steps
          echo "OUTPUT_DIR=$OUTPUT_DIR" >> $GITHUB_ENV

      - name: Upload Charts
        uses: actions/upload-artifact@v4
        with:
          name: benchmark-charts
          path: ${{ env.OUTPUT_DIR }}/
          retention-days: 365

      - name: Commit Results
        env:
          IS_PROVISIONAL: ${{ needs.launch.outputs.is_provisional }}
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          if [[ "$IS_PROVISIONAL" == "true" ]]; then
            git add -f results/provisional/
          else
            git add -f results/latest/

            # For releases, also create version folder
            if [ "${{ github.event_name }}" == "release" ]; then
              VERSION="${{ github.event.release.tag_name }}"
              mkdir -p "results/${VERSION}/arm64" "results/${VERSION}/x86"

              if [ -d "results/latest/arm64" ]; then
                cp -r results/latest/arm64/* "results/${VERSION}/arm64/" 2>/dev/null || true
              fi
              if [ -d "results/latest/x86" ]; then
                cp -r results/latest/x86/* "results/${VERSION}/x86/" 2>/dev/null || true
              fi

              echo "Release: ${VERSION}" > "results/${VERSION}/RELEASE_INFO"
              echo "Date: $(date -u)" >> "results/${VERSION}/RELEASE_INFO"
              git add -f "results/${VERSION}/"
            fi
          fi

          git commit -m "chore: update benchmark results [skip ci]" || echo "No changes to commit"
          git push || echo "Push failed (may need permissions)"

      - name: Create Summary
        env:
          IS_PROVISIONAL: ${{ needs.launch.outputs.is_provisional }}
          INSTANCE_MODE: ${{ needs.launch.outputs.instance_mode }}
        run: |
          if [[ "$IS_PROVISIONAL" == "true" ]]; then
            echo "# PROVISIONAL Benchmark Results" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "> **Warning**: These results are PROVISIONAL (run on $INSTANCE_MODE)." >> $GITHUB_STEP_SUMMARY
            echo "> Metal instances were unavailable. Run the **Promote Provisional** workflow when metal quota is available." >> $GITHUB_STEP_SUMMARY
          else
            echo "# Official Metal Benchmark Results" >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Instance mode**: $INSTANCE_MODE" >> $GITHUB_STEP_SUMMARY
          echo "**Triggered by**: ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "## ARM64 Results" >> $GITHUB_STEP_SUMMARY
          if [ -f "${{ env.OUTPUT_DIR }}/arm64/summary_arm64.md" ]; then
            cat "${{ env.OUTPUT_DIR }}/arm64/summary_arm64.md" >> $GITHUB_STEP_SUMMARY
          else
            echo "No ARM64 results available" >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## x86 Results" >> $GITHUB_STEP_SUMMARY
          if [ -f "${{ env.OUTPUT_DIR }}/x86/summary_x86.md" ]; then
            cat "${{ env.OUTPUT_DIR }}/x86/summary_x86.md" >> $GITHUB_STEP_SUMMARY
          else
            echo "No x86 results available" >> $GITHUB_STEP_SUMMARY
          fi

  cleanup:
    name: Cleanup Infrastructure
    needs: [authorize, launch, benchmark-arm64, benchmark-x86]
    runs-on: ubuntu-latest
    if: always() && needs.authorize.outputs.authorized == 'true'

    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.6.0"

      - name: Terraform Destroy
        working-directory: terraform
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          TF_VAR_gh_pat_runner_token: ${{ secrets.GH_PAT_RUNNER_TOKEN }}
          TF_VAR_use_provisional: ${{ contains(needs.launch.outputs.instance_mode, 'provisional') && 'true' || 'false' }}
          TF_VAR_use_on_demand: ${{ contains(needs.launch.outputs.instance_mode, 'ondemand') && 'true' || 'false' }}
        run: |
          terraform init
          terraform destroy -auto-approve || true
